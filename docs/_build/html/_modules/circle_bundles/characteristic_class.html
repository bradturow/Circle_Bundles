

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>circle_bundles.characteristic_class &mdash; circle_bundles 0+unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/myst_sphinx_gallery.css?v=92de7a9e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=27db1736"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            circle_bundles
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#basic-installation">Basic installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#optional-dependencies">Optional dependencies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#minimal-working-example">Minimal working example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#notes">Notes</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../theory/index.html">Theory</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/core_pipeline.html">Core pipeline</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.build_bundle.html">circle_bundles.build_bundle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.BundleResult.html">circle_bundles.BundleResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.DreimacCCConfig.html">circle_bundles.DreimacCCConfig</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.LocalTrivResult.html">circle_bundles.LocalTrivResult</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/covers.html">Covers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.MetricBallCover.html">circle_bundles.MetricBallCover</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.TriangulationStarCover.html">circle_bundles.TriangulationStarCover</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.make_s2_fibonacci_star_cover.html">circle_bundles.make_s2_fibonacci_star_cover</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.make_rp2_fibonacci_star_cover.html">circle_bundles.make_rp2_fibonacci_star_cover</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/metrics.html">Metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.EuclideanMetric.html">circle_bundles.EuclideanMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.S1AngleMetric.html">circle_bundles.S1AngleMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.RP1AngleMetric.html">circle_bundles.RP1AngleMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.S1UnitVectorMetric.html">circle_bundles.S1UnitVectorMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.RP1UnitVectorMetric.html">circle_bundles.RP1UnitVectorMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.RP2UnitVectorMetric.html">circle_bundles.RP2UnitVectorMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.T2FlatMetric.html">circle_bundles.T2FlatMetric</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/characteristic_classes.html">Characteristic classes and transitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.O2Cocycle.html">circle_bundles.O2Cocycle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.TransitionReport.html">circle_bundles.TransitionReport</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.ClassResult.html">circle_bundles.ClassResult</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/coordinatization.html">Coordinatization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.GlobalTrivializationResult.html">circle_bundles.GlobalTrivializationResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.BundleMapResult.html">circle_bundles.BundleMapResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.PullbackTotalSpaceResult.html">circle_bundles.PullbackTotalSpaceResult</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/weights_filtration.html">Weights filtration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.PersistenceResult.html">circle_bundles.PersistenceResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.CobirthResult.html">circle_bundles.CobirthResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.CodeathResult.html">circle_bundles.CodeathResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.MaxTrivialSubcomplex.html">circle_bundles.MaxTrivialSubcomplex</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/analysis.html">Analysis utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.fiberwise_clustering.html">circle_bundles.fiberwise_clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_cluster_persistence.html">circle_bundles.get_cluster_persistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_filtered_cluster_graph.html">circle_bundles.get_filtered_cluster_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_local_pca.html">circle_bundles.get_local_pca</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_local_pca.html">circle_bundles.plot_local_pca</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_local_rips.html">circle_bundles.get_local_rips</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_local_rips.html">circle_bundles.plot_local_rips</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_fiberwise_pca_grid.html">circle_bundles.plot_fiberwise_pca_grid</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_fiberwise_summary_bars.html">circle_bundles.plot_fiberwise_summary_bars</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_cocycle_dict.html">circle_bundles.get_cocycle_dict</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.lift_base_points.html">circle_bundles.lift_base_points</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../extras/index.html">Extras and utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../extras/synthetic.html">Synthetic datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/viz.html">Visualization Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/optical_flow.html">Optical Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/special_metrics.html">Specialized and quotient metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.Torus_DiagQuotientMetric_R4.html">circle_bundles.Torus_DiagQuotientMetric_R4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.Torus_KleinQuotientMetric_R4.html">circle_bundles.Torus_KleinQuotientMetric_R4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.RP2_TrivialMetric.html">circle_bundles.RP2_TrivialMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.RP2_TwistMetric.html">circle_bundles.RP2_TwistMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.RP2_FlipMetric.html">circle_bundles.RP2_FlipMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.S3QuotientMetric.html">circle_bundles.S3QuotientMetric</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/auto_examples/index.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/core/index.html">Core</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/01_product_torus.html">Product Torus</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/02_synthetic_natural_image_patches.html">Synthetic Natural Image Patches</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/03_triangle_meshes.html">Triangle Meshes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/04_tri_prism_densities.html">Triangle Prism Densities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/05_star_density_unwrapping.html">Star Density Unwrapping</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/optical_flow/index.html">Optical Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/optical_flow/01_optical_flow_torus.html">Optical Flow Torus</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/quotients/index.html">Quotients</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/quotients/01_quotients_of_s2_trivial.html">Quotients <span class="math notranslate nohighlight">\((\mathbb{S}^{2}\times\mathbb{S}^{1})/\mathbb{Z}_{2}\)</span> As Circle Bundles Over <span class="math notranslate nohighlight">\(\mathbb{RP}^{2}\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/quotients/02_lens_spaces.html">Lens Spaces <span class="math notranslate nohighlight">\(L(p,1) = \mathbb{S}^{3}/\mathbb{Z}_{p}\)</span> As Circle Bundles Over <span class="math notranslate nohighlight">\(\mathbb{S}^{2}\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/quotients/03_non_orientable_over_rp2.html">Quotients <span class="math notranslate nohighlight">\(\mathbb{S}^{3}/(\mathbb{Z}_{2p}\rtimes\mathbb{Z}_{2})\)</span> As Circle Bundles Over <span class="math notranslate nohighlight">\(\mathbb{RP}^{2}\)</span></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/index.html#core">Core</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/index.html#optical-flow">Optical Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/index.html#quotients">Quotients</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">circle_bundles</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">circle_bundles.characteristic_class</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for circle_bundles.characteristic_class</h1><div class="highlight"><pre>
<span></span><span class="c1"># characteristic_class.py</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Characteristic classes for O(2)-bundles on a nerve (supports up to 3-simplices).</span>

<span class="sd">Main entrypoint:</span>
<span class="sd">    compute_classes(cover, cocycle, ...)</span>

<span class="sd">Assumptions / conventions</span>
<span class="sd">-------------------------</span>
<span class="sd">- We work on a simplicial complex given by (edges, triangles, tets).</span>
<span class="sd">- Edges are represented canonically using combinatorics.canon_edge (min,max).</span>
<span class="sd">- Triangles are represented canonically using combinatorics.canon_tri (sorted).</span>
<span class="sd">- Tetrahedra are represented canonically as sorted 4-tuples.</span>

<span class="sd">- The O(2) cocycle object is assumed to provide:</span>
<span class="sd">    - restrict(edges) -&gt; cocycle restricted to those edges</span>
<span class="sd">    - omega_Z2()      -&gt; dict edge -&gt; {0,1}  (det -&gt; Z2)</span>
<span class="sd">    - omega_O1()      -&gt; dict edge -&gt; {+1,-1}</span>
<span class="sd">    - theta_normalized() -&gt; dict edge -&gt; float in R/Z (represented mod 1)</span>
<span class="sd">    - orient_if_possible(edges, n_vertices) -&gt; (ok, cocycle_out, phi_pm1_array)</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">- The twisted Euler representative e is computed by rounding δ_ω θ on triangles.</span>
<span class="sd">- If 3-simplices are present, we DO NOT assume e is a cocycle: we check δ_ω e on tets.</span>
<span class="sd">- Euler number computation:</span>
<span class="sd">    * If H_2(B; Z~) has free rank 1, compute integer pairing (twisted Euler number),</span>
<span class="sd">      regardless of orientability of the base.</span>
<span class="sd">    * If free rank != 1, do not compute integer pairing.</span>
<span class="sd">    * If H_2(B; Z2) has dimension 1, compute mod-2 pairing.</span>
<span class="sd">    * Otherwise, mod-2 pairing is not computed.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Set</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.nerve.combinatorics</span><span class="w"> </span><span class="kn">import</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">Tri</span><span class="p">,</span> <span class="n">canon_edge</span><span class="p">,</span> <span class="n">canon_tri</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.analysis.class_persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">build_delta_C0_to_C1_Z2</span><span class="p">,</span> <span class="n">build_delta_C1_to_C2_Z_twisted</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.analysis.class_persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">in_image_mod2</span><span class="p">,</span> <span class="n">in_image_Z_fast_pipeline</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;ClassResult&quot;</span>
<span class="p">]</span>

<span class="c1"># ============================================================</span>
<span class="c1"># Canonicalization</span>
<span class="c1"># ============================================================</span>

<span class="n">Tet</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">canon_tet</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tet</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">))))</span>


<span class="c1"># ============================================================</span>
<span class="c1"># R/Z lift helper</span>
<span class="c1"># ============================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">principal_lift_RZ</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    x in R/Z represented as float (mod 1).</span>
<span class="sd">    Return the principal lift in (-1/2, 1/2].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="c1"># ============================================================</span>
<span class="c1"># O(1) cochain canonicalization</span>
<span class="c1"># ============================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">canonicalize_o1_cochain</span><span class="p">(</span><span class="n">omega_O1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Force an O(1) 1-cochain (±1) to use canonical edge keys (min,max).</span>
<span class="sd">    If both orientations are present, require consistency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">omega_O1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;omega_O1 values must be ±1; got </span><span class="si">{</span><span class="n">vv</span><span class="si">}</span><span class="s2"> on edge </span><span class="si">{</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">out</span> <span class="ow">and</span> <span class="n">out</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vv</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inconsistent omega_O1 values on edge </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">out</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">vv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">vv</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Twisted coboundaries (2 and 3)</span>
<span class="c1"># ============================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">twisted_delta_theta_real</span><span class="p">(</span><span class="n">tri</span><span class="p">:</span> <span class="n">Tri</span><span class="p">,</span> <span class="n">theta_norm</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">omega_O1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    δ_ω θ(i,j,k) = ω(i,j) θ(j,k) - θ(i,k) + θ(i,j)</span>
<span class="sd">    with tri = (i&lt;j&lt;k), edges canonical.</span>

<span class="sd">    theta_norm values are in R/Z as floats mod 1.</span>
<span class="sd">    We principal-lift each to (-1/2, 1/2] before forming the coboundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tri</span>
    <span class="n">e01</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="n">e12</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">e02</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="n">w01</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">omega_O1</span><span class="p">[</span><span class="n">e01</span><span class="p">])</span>

    <span class="n">t01</span> <span class="o">=</span> <span class="n">principal_lift_RZ</span><span class="p">(</span><span class="n">theta_norm</span><span class="p">[</span><span class="n">e01</span><span class="p">])</span>
    <span class="n">t12</span> <span class="o">=</span> <span class="n">principal_lift_RZ</span><span class="p">(</span><span class="n">theta_norm</span><span class="p">[</span><span class="n">e12</span><span class="p">])</span>
    <span class="n">t02</span> <span class="o">=</span> <span class="n">principal_lift_RZ</span><span class="p">(</span><span class="n">theta_norm</span><span class="p">[</span><span class="n">e02</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">w01</span> <span class="o">*</span> <span class="n">t12</span> <span class="o">-</span> <span class="n">t02</span> <span class="o">+</span> <span class="n">t01</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">twisted_delta_euler_on_tet</span><span class="p">(</span><span class="n">tet</span><span class="p">:</span> <span class="n">Tet</span><span class="p">,</span> <span class="n">euler</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">omega_O1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3D twisted coboundary of an integer 2-cochain e on a tetrahedron (i&lt;j&lt;k&lt;l):</span>

<span class="sd">      (δ_ω e)(i,j,k,l) = ω(i,j) e(j,k,l) - e(i,k,l) + e(i,j,l) - e(i,j,k)</span>

<span class="sd">    Returns an integer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">tet</span>

    <span class="n">w01</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">omega_O1</span><span class="p">[</span><span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)])</span>

    <span class="n">t_jkl</span> <span class="o">=</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
    <span class="n">t_ikl</span> <span class="o">=</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
    <span class="n">t_ijl</span> <span class="o">=</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
    <span class="n">t_ijk</span> <span class="o">=</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">w01</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">euler</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t_jkl</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">euler</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t_ikl</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">euler</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t_ijl</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">euler</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t_ijk</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">compute_twisted_euler_class</span><span class="p">(</span><span class="n">cocycle</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">triangles</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tri</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    cocycle: O2Cocycle-like object (expects theta_normalized() and omega_O1()).</span>
<span class="sd">    triangles: iterable of triangles (any order; we canonicalize).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    e_rep: dict tri -&gt; int</span>
<span class="sd">    rounding_dist: float (max |delta - round(delta)|)</span>
<span class="sd">    e_real: dict tri -&gt; float</span>
<span class="sd">    omega_O1_used: dict edge -&gt; ±1 (canonical keys)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">theta_norm_raw</span> <span class="o">=</span> <span class="n">cocycle</span><span class="o">.</span><span class="n">theta_normalized</span><span class="p">()</span>
    <span class="n">theta_norm</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">canon_edge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">theta_norm_raw</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">omega_O1_raw</span> <span class="o">=</span> <span class="n">cocycle</span><span class="o">.</span><span class="n">omega_O1</span><span class="p">()</span>
    <span class="n">omega_O1_used</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">canonicalize_o1_cochain</span><span class="p">(</span><span class="n">omega_O1_raw</span><span class="p">)</span>

    <span class="n">e_real</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">e_rep</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">max_dev</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">canon_tri</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">twisted_delta_theta_real</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">theta_norm</span><span class="p">,</span> <span class="n">omega_O1_used</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="n">e_real</span><span class="p">[</span><span class="n">tri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">e_rep</span><span class="p">[</span><span class="n">tri</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="n">max_dev</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_dev</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">r</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">e_rep</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_dev</span><span class="p">),</span> <span class="n">e_real</span><span class="p">,</span> <span class="n">omega_O1_used</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Boundary matrices (twisted over Z, untwisted over Z2)</span>
<span class="c1"># ============================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">build_twisted_boundary_C2_to_C1</span><span class="p">(</span>
    <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span>
    <span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">],</span>
    <span class="n">omega_O1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Twisted boundary ∂_2^ω : C2 -&gt; C1 over Z.</span>

<span class="sd">    Consistent with:</span>
<span class="sd">      δ_ω θ(i,j,k) = ω(i,j)θ(j,k) - θ(i,k) + θ(i,j)</span>

<span class="sd">    So:</span>
<span class="sd">      ∂_ω [i,j,k] = ω(i,j)[j,k] - [i,k] + [i,j]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">canon_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
    <span class="n">triangles</span> <span class="o">=</span> <span class="p">[</span><span class="n">canon_tri</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">]</span>
    <span class="n">edge_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)}</span>

    <span class="n">omega_O1</span> <span class="o">=</span> <span class="n">canonicalize_o1_cochain</span><span class="p">(</span><span class="n">omega_O1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">omega_O1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;omega_O1 missing required edge </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">triangles</span><span class="p">):</span>
        <span class="n">eij</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">ejk</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">eik</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">w01</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">omega_O1</span><span class="p">[</span><span class="n">eij</span><span class="p">])</span>
        <span class="n">D</span><span class="p">[</span><span class="n">edge_index</span><span class="p">[</span><span class="n">ejk</span><span class="p">],</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w01</span>
        <span class="n">D</span><span class="p">[</span><span class="n">edge_index</span><span class="p">[</span><span class="n">eik</span><span class="p">],</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">D</span><span class="p">[</span><span class="n">edge_index</span><span class="p">[</span><span class="n">eij</span><span class="p">],</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="o">+</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">D</span>


<span class="k">def</span><span class="w"> </span><span class="nf">build_twisted_boundary_C3_to_C2</span><span class="p">(</span>
    <span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">],</span>
    <span class="n">tets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">],</span>
    <span class="n">omega_O1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Twisted boundary ∂_3^ω : C3 -&gt; C2 over Z.</span>

<span class="sd">    Convention (i&lt;j&lt;k&lt;l):</span>
<span class="sd">      ∂_ω [i,j,k,l] = ω(i,j)[j,k,l] - [i,k,l] + [i,j,l] - [i,j,k]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">triangles</span> <span class="o">=</span> <span class="p">[</span><span class="n">canon_tri</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">]</span>
    <span class="n">tets</span> <span class="o">=</span> <span class="p">[</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tets</span><span class="p">]</span>

    <span class="n">tri_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">:</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">triangles</span><span class="p">)}</span>

    <span class="n">omega_O1</span> <span class="o">=</span> <span class="n">canonicalize_o1_cochain</span><span class="p">(</span><span class="n">omega_O1</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tets</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tets</span><span class="p">):</span>
        <span class="n">w01</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">omega_O1</span><span class="p">[</span><span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)])</span>

        <span class="n">t_jkl</span> <span class="o">=</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">t_ikl</span> <span class="o">=</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">t_ijl</span> <span class="o">=</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">t_ijk</span> <span class="o">=</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="c1"># require all faces present in triangle basis</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="p">(</span><span class="n">t_jkl</span><span class="p">,</span> <span class="n">t_ikl</span><span class="p">,</span> <span class="n">t_ijl</span><span class="p">,</span> <span class="n">t_ijk</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">face</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tri_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tetrahedron face </span><span class="si">{</span><span class="n">face</span><span class="si">}</span><span class="s2"> not found in triangles list; ensure triangles include all faces.&quot;</span><span class="p">)</span>

        <span class="n">D</span><span class="p">[</span><span class="n">tri_index</span><span class="p">[</span><span class="n">t_jkl</span><span class="p">],</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w01</span>
        <span class="n">D</span><span class="p">[</span><span class="n">tri_index</span><span class="p">[</span><span class="n">t_ikl</span><span class="p">],</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">D</span><span class="p">[</span><span class="n">tri_index</span><span class="p">[</span><span class="n">t_ijl</span><span class="p">],</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="o">+</span><span class="mi">1</span>
        <span class="n">D</span><span class="p">[</span><span class="n">tri_index</span><span class="p">[</span><span class="n">t_ijk</span><span class="p">],</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">D</span>


<span class="k">def</span><span class="w"> </span><span class="nf">build_boundary_mod2_C2_to_C1</span><span class="p">(</span><span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span> <span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Standard boundary ∂_2 : C2 -&gt; C1 over Z2 (represented as uint8 matrix).</span>
<span class="sd">    ∂[i,j,k] = [j,k] + [i,k] + [i,j] mod 2 (signs vanish in Z2).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">canon_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
    <span class="n">triangles</span> <span class="o">=</span> <span class="p">[</span><span class="n">canon_tri</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">]</span>
    <span class="n">edge_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)}</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">triangles</span><span class="p">):</span>
        <span class="n">D</span><span class="p">[</span><span class="n">edge_index</span><span class="p">[</span><span class="n">canon_edge</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)],</span> <span class="n">c</span><span class="p">]</span> <span class="o">^=</span> <span class="mi">1</span>
        <span class="n">D</span><span class="p">[</span><span class="n">edge_index</span><span class="p">[</span><span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)],</span> <span class="n">c</span><span class="p">]</span> <span class="o">^=</span> <span class="mi">1</span>
        <span class="n">D</span><span class="p">[</span><span class="n">edge_index</span><span class="p">[</span><span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)],</span> <span class="n">c</span><span class="p">]</span> <span class="o">^=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">D</span>


<span class="k">def</span><span class="w"> </span><span class="nf">build_boundary_mod2_C3_to_C2</span><span class="p">(</span><span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">],</span> <span class="n">tets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Standard boundary ∂_3 : C3 -&gt; C2 over Z2 (uint8).</span>
<span class="sd">    ∂[i,j,k,l] = [j,k,l] + [i,k,l] + [i,j,l] + [i,j,k] mod 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">triangles</span> <span class="o">=</span> <span class="p">[</span><span class="n">canon_tri</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">]</span>
    <span class="n">tets</span> <span class="o">=</span> <span class="p">[</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tets</span><span class="p">]</span>
    <span class="n">tri_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">:</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">triangles</span><span class="p">)}</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tets</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tets</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="p">(</span><span class="n">canon_tri</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">face</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tri_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tet face </span><span class="si">{</span><span class="n">face</span><span class="si">}</span><span class="s2"> not found in triangles list; ensure triangles include all faces.&quot;</span><span class="p">)</span>
            <span class="n">D</span><span class="p">[</span><span class="n">tri_index</span><span class="p">[</span><span class="n">face</span><span class="p">],</span> <span class="n">c</span><span class="p">]</span> <span class="o">^=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">D</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Linear algebra helpers (Q and mod2)</span>
<span class="c1"># ============================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">rank_over_Q</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">())</span>


<span class="k">def</span><span class="w"> </span><span class="nf">nullspace_over_Q</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># nullspace of 0xN is full space; caller should handle dimensions carefully</span>
        <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">in_colspace_over_Q</span><span class="p">(</span><span class="n">M</span><span class="p">:</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if v is in the column space of M over Q.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row_join</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">())</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">rank</span><span class="p">())</span>


<span class="k">def</span><span class="w"> </span><span class="nf">rref_mod2</span><span class="p">(</span><span class="n">A_in</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute RREF of A over GF(2). Returns (RREF_matrix, pivot_cols).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">A_in</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pivots</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">r</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">pivot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">pivot</span> <span class="o">!=</span> <span class="n">row</span><span class="p">:</span>
            <span class="n">A</span><span class="p">[[</span><span class="n">row</span><span class="p">,</span> <span class="n">pivot</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[[</span><span class="n">pivot</span><span class="p">,</span> <span class="n">row</span><span class="p">],</span> <span class="p">:]</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">:]</span> <span class="o">^=</span> <span class="n">A</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">pivots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">pivots</span>


<span class="k">def</span><span class="w"> </span><span class="nf">nullspace_basis_mod2</span><span class="p">(</span><span class="n">A_in</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a basis for nullspace of A over GF(2).</span>
<span class="sd">    A shape: (m,n). Returns list of length nullity, each vector length n (uint8).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">A_in</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">R</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="n">rref_mod2</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">pivot_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pivots</span><span class="p">)</span>
    <span class="n">free_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pivot_set</span><span class="p">]</span>

    <span class="n">basis</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">free</span> <span class="ow">in</span> <span class="n">free_cols</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">x</span><span class="p">[</span><span class="n">free</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># back substitute (R is RREF, pivot i on row i)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pivots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ones</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">s</span> <span class="o">^=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">x</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">&amp;</span> <span class="mi">1</span>
        <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">basis</span>


<span class="k">def</span><span class="w"> </span><span class="nf">in_image_mod2</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decide if b is in the column space of A over GF(2).&quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">piv</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">piv</span> <span class="o">=</span> <span class="n">r</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">piv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">piv</span> <span class="o">!=</span> <span class="n">row</span><span class="p">:</span>
            <span class="n">M</span><span class="p">[[</span><span class="n">row</span><span class="p">,</span> <span class="n">piv</span><span class="p">]]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[[</span><span class="n">piv</span><span class="p">,</span> <span class="n">row</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">row</span> <span class="ow">and</span> <span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">:]</span> <span class="o">^=</span> <span class="n">M</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Fundamental class + pairing in general 3D case</span>
<span class="c1"># ============================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">normalize_cycle_Z</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">z</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="k">if</span> <span class="n">g</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">//=</span> <span class="n">g</span>
    <span class="n">first</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span>
    <span class="k">return</span> <span class="n">z</span>


<span class="k">def</span><span class="w"> </span><span class="nf">H2_dimensions</span><span class="p">(</span>
    <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span>
    <span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">],</span>
    <span class="n">tets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">],</span>
    <span class="n">omega_O1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute:</span>
<span class="sd">      dim_Q = dim H_2(B; Z~) over Q (free rank)</span>
<span class="sd">      dim_Z2 = dim H_2(B; Z2)</span>
<span class="sd">    using boundaries ∂2 and ∂3.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">})</span>
    <span class="n">triangles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_tri</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">})</span>
    <span class="n">tets</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tets</span><span class="p">})</span>

    <span class="c1"># Twisted (Z~) over Q</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dim_Q</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dim_Z2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;dim_Q&quot;</span><span class="p">:</span> <span class="n">dim_Q</span><span class="p">,</span> <span class="s2">&quot;dim_Z2&quot;</span><span class="p">:</span> <span class="n">dim_Z2</span><span class="p">}</span>

    <span class="n">D2w</span> <span class="o">=</span> <span class="n">build_twisted_boundary_C2_to_C1</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">omega_O1</span><span class="o">=</span><span class="n">omega_O1</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">rank_over_Q</span><span class="p">(</span><span class="n">D2w</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span>
    <span class="n">ker2_dim</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-</span> <span class="n">r2</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">im3_dim</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D3w</span> <span class="o">=</span> <span class="n">build_twisted_boundary_C3_to_C2</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">tets</span><span class="p">,</span> <span class="n">omega_O1</span><span class="o">=</span><span class="n">omega_O1</span><span class="p">)</span>
        <span class="n">im3_dim</span> <span class="o">=</span> <span class="n">rank_over_Q</span><span class="p">(</span><span class="n">D3w</span><span class="p">)</span>

    <span class="n">dim_Q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ker2_dim</span> <span class="o">-</span> <span class="n">im3_dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Mod 2 (untwisted)</span>
    <span class="n">D2</span> <span class="o">=</span> <span class="n">build_boundary_mod2_C2_to_C1</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>
    <span class="n">R2</span><span class="p">,</span> <span class="n">piv2</span> <span class="o">=</span> <span class="n">rref_mod2</span><span class="p">(</span><span class="n">D2</span><span class="p">)</span>
    <span class="n">ker2_dim2</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">piv2</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">im3_dim2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D3</span> <span class="o">=</span> <span class="n">build_boundary_mod2_C3_to_C2</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">tets</span><span class="p">)</span>
        <span class="c1"># image dim is rank of D3 over GF2; rank is #pivots of RREF of D3</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">piv3</span> <span class="o">=</span> <span class="n">rref_mod2</span><span class="p">(</span><span class="n">D3</span><span class="p">)</span>
        <span class="n">im3_dim2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">piv3</span><span class="p">)</span>

    <span class="n">dim_Z2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ker2_dim2</span> <span class="o">-</span> <span class="n">im3_dim2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;dim_Q&quot;</span><span class="p">:</span> <span class="n">dim_Q</span><span class="p">,</span> <span class="s2">&quot;dim_Z2&quot;</span><span class="p">:</span> <span class="n">dim_Z2</span><span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">fundamental_class_Z_rank1</span><span class="p">(</span>
    <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span>
    <span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">],</span>
    <span class="n">tets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">],</span>
    <span class="n">omega_O1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If dim H2(B; Z~) over Q is 1, return an integer 2-cycle z (length #triangles)</span>
<span class="sd">    representing the generator (up to sign).</span>
<span class="sd">    Otherwise return None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">})</span>
    <span class="n">triangles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_tri</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">})</span>
    <span class="n">tets</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tets</span><span class="p">})</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">D2w</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">build_twisted_boundary_C2_to_C1</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">omega_O1</span><span class="o">=</span><span class="n">omega_O1</span><span class="p">))</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">D2w</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>  <span class="c1"># basis for Z2 cycles over Q (actually kernel of ∂2)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># H2 dim = dim ker(∂2)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D3w</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">build_twisted_boundary_C3_to_C2</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">tets</span><span class="p">,</span> <span class="n">omega_O1</span><span class="o">=</span><span class="n">omega_O1</span><span class="p">))</span>
        <span class="c1"># pick a kernel vector not in image(∂3)</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v0</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_colspace_over_Q</span><span class="p">(</span><span class="n">D3w</span><span class="p">,</span> <span class="n">v0</span><span class="p">):</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Either dim != 1 or ambiguity; we refuse.</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># clear denominators to integer</span>
    <span class="n">lcm</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">lcm</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">ilcm</span><span class="p">(</span><span class="n">lcm</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">xr</span><span class="o">.</span><span class="n">q</span><span class="p">)))</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">lcm</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">normalize_cycle_Z</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">fundamental_class_Z2_rank1</span><span class="p">(</span>
    <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span>
    <span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">],</span>
    <span class="n">tets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If dim H2(B; Z2) is 1, return a mod-2 2-cycle vector z2 (length #triangles)</span>
<span class="sd">    representing the generator class (up to sign, but sign is irrelevant mod 2).</span>
<span class="sd">    Otherwise return None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">})</span>
    <span class="n">triangles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_tri</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">})</span>
    <span class="n">tets</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tets</span><span class="p">})</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">D2</span> <span class="o">=</span> <span class="n">build_boundary_mod2_C2_to_C1</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>  <span class="c1"># (E x T)</span>
    <span class="c1"># cycles are vectors in ker(D2)</span>
    <span class="n">ker_basis</span> <span class="o">=</span> <span class="n">nullspace_basis_mod2</span><span class="p">(</span><span class="n">D2</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ker_basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># H2 dim = dim ker</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ker_basis</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">ker_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">D3</span> <span class="o">=</span> <span class="n">build_boundary_mod2_C3_to_C2</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">tets</span><span class="p">)</span>  <span class="c1"># (T x Tet)</span>
    <span class="c1"># image(D3) is column space in T-dim</span>
    <span class="c1"># find a kernel vector not in image(D3)</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ker_basis</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_image_mod2</span><span class="p">(</span><span class="n">D3</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>  <span class="c1"># v in colspace(D3)?</span>
            <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">euler_pairing_Z</span><span class="p">(</span><span class="n">e_class</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">],</span> <span class="n">z_fund_Z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tri</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">triangles</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e_class</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">z_fund_Z</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">euler_pairing_Z2</span><span class="p">(</span><span class="n">e_class</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">],</span> <span class="n">z_fund_Z2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tri</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">triangles</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">^=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">e_class</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">int</span><span class="p">(</span><span class="n">z_fund_Z2</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">acc</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Class computation + reporting</span>
<span class="c1"># ============================================================</span>

<div class="viewcode-block" id="ClassResult">
<a class="viewcode-back" href="../../api/generated/circle_bundles.ClassResult.html#circle_bundles.ClassResult">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Output bundle invariants and diagnostics for an O(2)-cocycle on a finite nerve.</span>

<span class="sd">    This object summarizes:</span>
<span class="sd">    - the orientability obstruction (w1),</span>
<span class="sd">    - the twisted Euler representative on triangles (ẽ) and its rounding quality,</span>
<span class="sd">    - optional 3D consistency checks on tetrahedra,</span>
<span class="sd">    - optional coboundary tests (“is the class trivial on this complex?”),</span>
<span class="sd">    - optional Euler-number pairings when H2 has rank 1,</span>
<span class="sd">    - and the mod-2 reduction (w2) used for spin diagnostics in the orientable case.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - All keys for edges/triangles are canonicalized (undirected edges, sorted triangles).</span>
<span class="sd">    - “On this complex” means with respect to the simplicial cochain complex induced by</span>
<span class="sd">      the provided (edges, triangles, tets). Refining the nerve can change coboundary</span>
<span class="sd">      tests and pairings.</span>
<span class="sd">    - The Euler representative is computed by rounding ``δ_ω θ`` on triangles. In a</span>
<span class="sd">      3-dimensional complex we explicitly check whether ``δ_ω ẽ = 0`` on tetrahedra</span>
<span class="sd">      before interpreting it as a cohomology class.</span>

<span class="sd">    The fields are intentionally explicit (rather than nested) so that summaries can be</span>
<span class="sd">    printed without additional computation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_vertices</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_edges</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_triangles</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_tets</span><span class="p">:</span> <span class="nb">int</span>

    <span class="n">sw1_Z2</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="n">sw1_O1</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

    <span class="c1"># whether ω passed the triangle cocycle check on this complex</span>
    <span class="n">sw1_is_cocycle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>

    <span class="c1"># ω is a coboundary in C^1 over Z2 (i.e. w1 = 0) on this complex</span>
    <span class="n">sw1_is_coboundary_Z2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>

    <span class="n">orientable</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">phi_pm1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>

    <span class="n">cocycle_used</span><span class="p">:</span> <span class="n">Any</span>

    <span class="n">euler_class</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="n">euler_class_real</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="n">rounding_dist</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">omega_O1_used</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

    <span class="c1"># Euler cocycle check in 3D (δ_ω e = 0 on tets). None if no tets.</span>
    <span class="n">euler_is_cocycle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>
    <span class="n">max_abs_delta_euler_on_tets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

    <span class="c1"># e is a twisted coboundary in C^2 over Z (i.e. e=0 or ẽ=0) on this complex</span>
    <span class="n">euler_is_coboundary_Z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>

    <span class="c1"># Homology info</span>
    <span class="n">H2_dim_Q</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">H2_dim_Z2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

    <span class="c1"># Pairings / invariants</span>
    <span class="n">twisted_euler_number_Z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">euler_number_mod2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

    <span class="n">sw2_Z2</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

    <span class="n">bundle_trivial_on_this_complex</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>
    <span class="n">spin_on_this_complex</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span></div>



        
<span class="k">def</span><span class="w"> </span><span class="nf">_sw1_cocycle_check_on_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">],</span> <span class="n">omega_Z2</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check δω = 0 on every triangle (mod 2):</span>
<span class="sd">      δω(i,j,k) = ω(j,k) - ω(i,k) + ω(i,j)  (mod 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
        <span class="n">eij</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">eik</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">ejk</span> <span class="o">=</span> <span class="n">canon_edge</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">omega_Z2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ejk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">omega_Z2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eik</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">omega_Z2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eij</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_infer_tets_from_cover</span><span class="p">(</span><span class="n">cover</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Try common method names; fall back to empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span> <span class="s2">&quot;nerve_tetrahedra&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">cover</span><span class="o">.</span><span class="n">nerve_tetrahedra</span><span class="p">()]</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span> <span class="s2">&quot;nerve_tets&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">cover</span><span class="o">.</span><span class="n">nerve_tets</span><span class="p">()]</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span> <span class="s2">&quot;nerve_3simplices&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">cover</span><span class="o">.</span><span class="n">nerve_3simplices</span><span class="p">()]</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span> <span class="s2">&quot;nerve_simplices&quot;</span><span class="p">):</span>
        <span class="c1"># sometimes nerve_simplices(dim) exists</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tets</span> <span class="o">=</span> <span class="n">cover</span><span class="o">.</span><span class="n">nerve_simplices</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tets</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">compute_classes</span><span class="p">(</span>
    <span class="n">cover</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">cocycle</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Edge</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">triangles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tri</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tet</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_vertices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">try_orient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">compute_euler_num</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClassResult</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">cover</span><span class="o">.</span><span class="n">nerve_edges</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">triangles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">cover</span><span class="o">.</span><span class="n">nerve_triangles</span><span class="p">()</span>

    <span class="n">edges_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">})</span>
    <span class="n">tris_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_tri</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">})</span>

    <span class="k">if</span> <span class="n">tets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tets_list</span> <span class="o">=</span> <span class="n">_infer_tets_from_cover</span><span class="p">(</span><span class="n">cover</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tets_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">canon_tet</span><span class="p">(</span><span class="o">*</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tets</span><span class="p">})</span>

    <span class="k">if</span> <span class="n">n_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges_list</span><span class="p">:</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tris_list</span><span class="p">:</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tets_list</span><span class="p">:</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">n_vertices</span> <span class="o">=</span> <span class="p">(</span><span class="n">mx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">mx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">cover</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Restrict cocycle to this 1-skeleton</span>
    <span class="n">coc_res</span> <span class="o">=</span> <span class="n">cocycle</span><span class="o">.</span><span class="n">restrict</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span>

    <span class="n">sw1_Z2</span> <span class="o">=</span> <span class="p">{</span><span class="n">canon_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">):</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">coc_res</span><span class="o">.</span><span class="n">omega_Z2</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">sw1_O1</span> <span class="o">=</span> <span class="n">canonicalize_o1_cochain</span><span class="p">(</span><span class="n">coc_res</span><span class="o">.</span><span class="n">omega_O1</span><span class="p">())</span>

    <span class="c1"># ---- SW1 cocycle check on triangles (δω=0 on each 2-simplex) ----</span>
    <span class="n">sw1_is_cocycle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tris_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sw1_is_cocycle</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_sw1_cocycle_check_on_triangles</span><span class="p">(</span><span class="n">tris_list</span><span class="p">,</span> <span class="n">sw1_Z2</span><span class="p">))</span>

    <span class="c1"># ---- SW1 coboundary check on edges (ω in Im δ: C^0-&gt;C^1 over Z2) ----</span>
    <span class="n">sw1_is_coboundary_Z2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># vertices as 0-simplices</span>
        <span class="n">V0</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">))]</span>
        <span class="n">A01</span> <span class="o">=</span> <span class="n">build_delta_C0_to_C1_Z2</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">V0</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges_list</span><span class="p">)</span>  <span class="c1"># (#E, #V)</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sw1_Z2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_list</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">sw1_is_coboundary_Z2</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">in_image_mod2</span><span class="p">(</span><span class="n">A01</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>

    <span class="c1"># Try to orient (may modify cocycle)</span>
    <span class="n">orientable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">phi_pm1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">coc_used</span> <span class="o">=</span> <span class="n">coc_res</span>

    <span class="k">if</span> <span class="n">try_orient</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ok</span><span class="p">,</span> <span class="n">coc_oriented</span><span class="p">,</span> <span class="n">phi_pm1</span> <span class="o">=</span> <span class="n">coc_res</span><span class="o">.</span><span class="n">orient_if_possible</span><span class="p">(</span><span class="n">edges_list</span><span class="p">,</span> <span class="n">n_vertices</span><span class="o">=</span><span class="n">n_vertices</span><span class="p">)</span>
        <span class="n">orientable</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">ok</span><span class="p">)</span>
        <span class="n">coc_used</span> <span class="o">=</span> <span class="n">coc_oriented</span> <span class="k">if</span> <span class="n">orientable</span> <span class="k">else</span> <span class="n">coc_res</span>

    <span class="c1"># ============================================================</span>
    <span class="c1"># Euler representative (triangle level)</span>
    <span class="c1"># ============================================================</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tris_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">euler_rep</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">euler_real</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">rounding_dist</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">omega_O1_used</span> <span class="o">=</span> <span class="n">canonicalize_o1_cochain</span><span class="p">(</span><span class="n">coc_used</span><span class="o">.</span><span class="n">omega_O1</span><span class="p">())</span>
        <span class="n">sw2</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tri</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">euler_is_cocycle</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_abs_delta</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">H2_dim_Q</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">H2_dim_Z2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">eZ</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">eZ2</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># no triangles =&gt; no Euler class rep =&gt; no coboundary test</span>
        <span class="n">euler_is_coboundary_Z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">bundle_trivial</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">spin</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">euler_rep</span><span class="p">,</span> <span class="n">rounding_dist</span><span class="p">,</span> <span class="n">euler_real</span><span class="p">,</span> <span class="n">omega_O1_used</span> <span class="o">=</span> <span class="n">compute_twisted_euler_class</span><span class="p">(</span><span class="n">coc_used</span><span class="p">,</span> <span class="n">tris_list</span><span class="p">)</span>

        <span class="c1"># restrict ω to exactly edges in this complex</span>
        <span class="n">omega_O1_used</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">omega_O1_used</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_list</span><span class="p">}</span>

        <span class="c1"># sw2 on triangles is e mod 2 (cochain-level)</span>
        <span class="n">sw2</span> <span class="o">=</span> <span class="p">{</span><span class="n">tri</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">tri</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">euler_rep</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># --- w2 coboundary check (spin) over Z2 ---</span>
        <span class="n">sw2_is_coboundary_Z2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">orientable</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tris_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># δ: C^1 -&gt; C^2 over Z2 is the transpose of ∂2: C2 -&gt; C1</span>
            <span class="n">D2_mod2</span> <span class="o">=</span> <span class="n">build_boundary_mod2_C2_to_C1</span><span class="p">(</span><span class="n">edges_list</span><span class="p">,</span> <span class="n">tris_list</span><span class="p">)</span>   <span class="c1"># (E x T)</span>
            <span class="n">A12_mod2</span> <span class="o">=</span> <span class="p">(</span><span class="n">D2_mod2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>                         <span class="c1"># (T x E)</span>

            <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sw2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tris_list</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># (T,)</span>
            <span class="n">sw2_is_coboundary_Z2</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">in_image_mod2</span><span class="p">(</span><span class="n">A12_mod2</span><span class="p">,</span> <span class="n">b2</span><span class="p">))</span>
        
        
        
        <span class="c1"># ---- 3D cocycle check for Euler class if tets exist ----</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tets_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">euler_is_cocycle</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">max_abs_delta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bad</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">max_abs</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tets_list</span><span class="p">:</span>
                <span class="n">dv</span> <span class="o">=</span> <span class="n">twisted_delta_euler_on_tet</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">euler_rep</span><span class="p">,</span> <span class="n">omega_O1_used</span><span class="p">)</span>
                <span class="n">max_abs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_abs</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">dv</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">dv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">bad</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">euler_is_cocycle</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">bad</span><span class="p">)</span>
            <span class="n">max_abs_delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_abs</span><span class="p">)</span>

        <span class="c1"># ---- Euler coboundary test (e in Im δ_ω: C^1-&gt;C^2 over Z) ----</span>
        <span class="n">euler_is_coboundary_Z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tris_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">A12</span> <span class="o">=</span> <span class="n">build_delta_C1_to_C2_Z_twisted</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges_list</span><span class="p">,</span> <span class="n">triangles</span><span class="o">=</span><span class="n">tris_list</span><span class="p">,</span> <span class="n">omega_O1</span><span class="o">=</span><span class="n">omega_O1_used</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">euler_rep</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tris_list</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

            <span class="c1"># Only meaningful if Euler rep is a valid 3D cocycle (or we are in 2D)</span>
            <span class="n">ok_e</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="n">euler_is_cocycle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="nb">bool</span><span class="p">(</span><span class="n">euler_is_cocycle</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ok_e</span><span class="p">:</span>
                <span class="n">euler_is_coboundary_Z</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">in_image_Z_fast_pipeline</span><span class="p">(</span><span class="n">A12</span><span class="p">,</span> <span class="n">b2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">euler_is_coboundary_Z</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># not a cocycle in 3D, so &quot;class&quot; undefined here</span>

        <span class="c1"># decide whether to compute pairings</span>
        <span class="n">H2_dim_Q</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">H2_dim_Z2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">eZ</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">eZ2</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">compute_euler_num</span><span class="p">:</span>
            <span class="n">ok_e</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="n">euler_is_cocycle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="nb">bool</span><span class="p">(</span><span class="n">euler_is_cocycle</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ok_e</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="n">H2_dimensions</span><span class="p">(</span><span class="n">edges_list</span><span class="p">,</span> <span class="n">tris_list</span><span class="p">,</span> <span class="n">tets_list</span><span class="p">,</span> <span class="n">omega_O1</span><span class="o">=</span><span class="n">omega_O1_used</span><span class="p">)</span>
                <span class="n">H2_dim_Q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="s2">&quot;dim_Q&quot;</span><span class="p">])</span>
                <span class="n">H2_dim_Z2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="s2">&quot;dim_Z2&quot;</span><span class="p">])</span>

                <span class="c1"># pairing conventions / availability logic</span>
                <span class="k">if</span> <span class="n">H2_dim_Q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">eZ</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="n">H2_dim_Q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">fundamental_class_Z_rank1</span><span class="p">(</span><span class="n">edges_list</span><span class="p">,</span> <span class="n">tris_list</span><span class="p">,</span> <span class="n">tets_list</span><span class="p">,</span> <span class="n">omega_O1</span><span class="o">=</span><span class="n">omega_O1_used</span><span class="p">)</span>
                    <span class="n">eZ</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">euler_pairing_Z</span><span class="p">(</span><span class="n">euler_rep</span><span class="p">,</span> <span class="n">tris_list</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eZ</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">H2_dim_Z2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">eZ2</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">H2_dim_Z2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">z2</span> <span class="o">=</span> <span class="n">fundamental_class_Z2_rank1</span><span class="p">(</span><span class="n">edges_list</span><span class="p">,</span> <span class="n">tris_list</span><span class="p">,</span> <span class="n">tets_list</span><span class="p">)</span>
                    <span class="n">eZ2</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">z2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">euler_pairing_Z2</span><span class="p">(</span><span class="n">euler_rep</span><span class="p">,</span> <span class="n">tris_list</span><span class="p">,</span> <span class="n">z2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eZ2</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># Quick “bundle trivial / spin” flags (use class-level tests)</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tets_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bundle_trivial</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">orientable</span> <span class="ow">and</span> <span class="p">(</span><span class="n">euler_is_coboundary_Z</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">bundle_trivial</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span>
                <span class="n">orientable</span> <span class="ow">and</span> <span class="p">(</span><span class="n">euler_is_cocycle</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">euler_is_coboundary_Z</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">spin</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">sw2_is_coboundary_Z2</span><span class="p">)</span> <span class="k">if</span> <span class="n">sw2_is_coboundary_Z2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

            
            
    <span class="k">return</span> <span class="n">ClassResult</span><span class="p">(</span>
        <span class="n">n_vertices</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">),</span>
        <span class="n">n_edges</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)),</span>
        <span class="n">n_triangles</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tris_list</span><span class="p">)),</span>
        <span class="n">n_tets</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tets_list</span><span class="p">)),</span>

        <span class="n">sw1_Z2</span><span class="o">=</span><span class="n">sw1_Z2</span><span class="p">,</span>
        <span class="n">sw1_O1</span><span class="o">=</span><span class="n">sw1_O1</span><span class="p">,</span>
        <span class="n">sw1_is_cocycle</span><span class="o">=</span><span class="n">sw1_is_cocycle</span><span class="p">,</span>

        <span class="n">sw1_is_coboundary_Z2</span><span class="o">=</span><span class="n">sw1_is_coboundary_Z2</span><span class="p">,</span>
        <span class="n">euler_is_coboundary_Z</span><span class="o">=</span><span class="n">euler_is_coboundary_Z</span><span class="p">,</span>

        <span class="n">orientable</span><span class="o">=</span><span class="n">orientable</span><span class="p">,</span>
        <span class="n">phi_pm1</span><span class="o">=</span><span class="n">phi_pm1</span><span class="p">,</span>
        <span class="n">cocycle_used</span><span class="o">=</span><span class="n">coc_used</span><span class="p">,</span>

        <span class="n">euler_class</span><span class="o">=</span><span class="n">euler_rep</span><span class="p">,</span>
        <span class="n">euler_class_real</span><span class="o">=</span><span class="n">euler_real</span><span class="p">,</span>
        <span class="n">rounding_dist</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">rounding_dist</span><span class="p">),</span>
        <span class="n">omega_O1_used</span><span class="o">=</span><span class="n">omega_O1_used</span><span class="p">,</span>

        <span class="n">euler_is_cocycle</span><span class="o">=</span><span class="n">euler_is_cocycle</span><span class="p">,</span>
        <span class="n">max_abs_delta_euler_on_tets</span><span class="o">=</span><span class="n">max_abs_delta</span><span class="p">,</span>

        <span class="n">H2_dim_Q</span><span class="o">=</span><span class="n">H2_dim_Q</span><span class="p">,</span>
        <span class="n">H2_dim_Z2</span><span class="o">=</span><span class="n">H2_dim_Z2</span><span class="p">,</span>

        <span class="n">twisted_euler_number_Z</span><span class="o">=</span><span class="n">eZ</span><span class="p">,</span>
        <span class="n">euler_number_mod2</span><span class="o">=</span><span class="n">eZ2</span><span class="p">,</span>

        <span class="n">sw2_Z2</span><span class="o">=</span><span class="n">sw2</span><span class="p">,</span>

        <span class="n">bundle_trivial_on_this_complex</span><span class="o">=</span><span class="n">bundle_trivial</span><span class="p">,</span>
        <span class="n">spin_on_this_complex</span><span class="o">=</span><span class="n">spin</span><span class="p">,</span>
    <span class="p">)</span>




<span class="k">def</span><span class="w"> </span><span class="nf">_euc_to_geo_rad</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert chordal distance d in [0,2] on S^1 ⊂ C to geodesic angle in radians in [0, π]:</span>
<span class="sd">        d = 2 sin(theta/2)  =&gt;  theta = 2 arcsin(d/2).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_fmt_euc_with_geo_pi</span><span class="p">(</span><span class="n">d_euc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">decimals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Render:</span>
<span class="sd">        &lt;d_euc&gt; (ε_triv^{geo}=&lt;theta/pi&gt;π)</span>
<span class="sd">    where &lt;theta&gt; is the geodesic angle in radians derived from chordal d_euc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d_euc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">d_euc</span><span class="p">)):</span>
        <span class="k">return</span> <span class="s2">&quot;—&quot;</span>
    <span class="n">d_euc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">d_euc</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">_euc_to_geo_rad</span><span class="p">(</span><span class="n">d_euc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d_euc</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d_euc</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2"> (</span><span class="se">\\</span><span class="s2">varepsilon_</span><span class="se">{{\\</span><span class="s2">text</span><span class="se">{{</span><span class="s2">triv</span><span class="se">}}}}</span><span class="s2">^</span><span class="se">{{\\</span><span class="s2">text</span><span class="se">{{</span><span class="s2">geo</span><span class="se">}}}}</span><span class="s2">=</span><span class="si">{</span><span class="n">theta</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="se">\\</span><span class="s2">pi)&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_fmt_mean_euc_with_geo_pi</span><span class="p">(</span><span class="n">d_euc_mean</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">decimals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Render:</span>
<span class="sd">        &lt;d_euc_mean&gt; (\bar{ε}_triv^{geo}=&lt;theta/pi&gt;π)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d_euc_mean</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">d_euc_mean</span><span class="p">)):</span>
        <span class="k">return</span> <span class="s2">&quot;—&quot;</span>
    <span class="n">d_euc_mean</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">d_euc_mean</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">_euc_to_geo_rad</span><span class="p">(</span><span class="n">d_euc_mean</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d_euc_mean</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d_euc_mean</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2"> (</span><span class="se">\\</span><span class="s2">bar</span><span class="se">{{\\</span><span class="s2">varepsilon</span><span class="se">}}</span><span class="s2">_</span><span class="se">{{\\</span><span class="s2">text</span><span class="se">{{</span><span class="s2">triv</span><span class="se">}}}}</span><span class="s2">^</span><span class="se">{{\\</span><span class="s2">text</span><span class="se">{{</span><span class="s2">geo</span><span class="se">}}}}</span><span class="s2">=</span><span class="si">{</span><span class="n">theta</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="se">\\</span><span class="s2">pi)&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">show_summary</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pretty summary of (1) diagnostics and (2) characteristic classes.</span>

<span class="sd">    User-facing conventions:</span>
<span class="sd">    - No explicit pairing notation is shown.</span>
<span class="sd">    - Euler number displayed as:</span>
<span class="sd">        * orientable:     &quot;Euler number: k (spin/not spin)&quot;</span>
<span class="sd">        * non-orientable: &quot;(twisted) Euler number: k&quot;</span>
<span class="sd">    - Reporting rules:</span>
<span class="sd">        * If (twisted) Euler class is trivial: report the (twisted) Euler class line and do NOT report Euler number.</span>
<span class="sd">        * If (twisted) Euler class is nontrivial and Euler number is available: report ONLY Euler number (do NOT also report Euler class).</span>
<span class="sd">        * If (twisted) Euler class is nontrivial and Euler number is unavailable (orientable only): report Euler class + spin class fallback.</span>
<span class="sd">    - If orientable AND Euler class is nontrivial BUT Euler number is undefined,</span>
<span class="sd">      report the spin class instead:</span>
<span class="sd">        &quot;Spin class: w₂ = 0 (spin)&quot; or &quot;Spin class: w₂ ≠ 0 (not spin)&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ----------------------------</span>
    <span class="c1"># Pull quantities</span>
    <span class="c1"># ----------------------------</span>
    <span class="n">eps_triv</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;eps_align_euc&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">eps_triv_mean</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;eps_align_euc_mean&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;delta&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">eps_coc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;cocycle_defect&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">rounding_dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;rounding_dist&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="n">orientable</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;orientable&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    <span class="n">n_tri</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;n_triangles&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># “is coboundary?” flags</span>
    <span class="n">w1_is_cob</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;sw1_is_coboundary_Z2&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w1_is_cob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># fallback: if orientable was inferred successfully, treat w1 as zero</span>
        <span class="n">w1_is_cob</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">orientable</span><span class="p">)</span>

    <span class="n">e_is_cob</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;euler_is_coboundary_Z&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">euler_rep</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;euler_class&quot;</span><span class="p">,</span> <span class="p">{})</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">e_trivial_cochain</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">euler_rep</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">euler_rep</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="n">e_zero_for_print</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">e_is_cob</span><span class="p">)</span> <span class="k">if</span> <span class="n">e_is_cob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">bool</span><span class="p">(</span><span class="n">e_trivial_cochain</span><span class="p">)</span>

    <span class="c1"># Euler number (integer pairing), when computed</span>
    <span class="n">eZ</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;twisted_euler_number_Z&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># w2 / spin fallback (only used when orientable + Euler number undefined)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_infer_w2_is_zero</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            True  if w2 = 0,</span>
<span class="sd">            False if w2 != 0,</span>
<span class="sd">            None  if unavailable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;spin_on_this_complex&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

        <span class="n">sw2</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;sw2_Z2&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sw2</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sw2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sw2</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># Build plain-text summary</span>
    <span class="c1"># ----------------------------</span>
    <span class="n">IND</span> <span class="o">=</span> <span class="s2">&quot;  &quot;</span>
    <span class="n">LABEL_W</span> <span class="o">=</span> <span class="mi">28</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tline</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">content</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">IND</span><span class="si">}{</span><span class="n">label</span><span class="si">:</span><span class="s2">&lt;</span><span class="si">{</span><span class="n">LABEL_W</span><span class="si">}}</span><span class="s2"> </span><span class="si">{</span><span class="n">content</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;=== Diagnostics ===&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">IND</span><span class="si">}</span><span class="s2">(no quality report provided)&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">eps_triv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">_tline</span><span class="p">(</span>
                    <span class="s2">&quot;trivialization error:&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ε_triv := sup_{(j k)∈N(U)} sup_{x∈π^{-1}(U_j∩U_k)} d_𝕮(Ω_</span><span class="si">{jk}</span><span class="s2"> f_k(x), f_j(x))&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; = </span><span class="si">{</span><span class="n">_fmt_euc_with_geo_pi</span><span class="p">(</span><span class="n">eps_triv</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">eps_triv_mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">_tline</span><span class="p">(</span>
                    <span class="s2">&quot;mean triv error:&quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">bar</span><span class="se">{{</span><span class="s2">ε</span><span class="se">}}</span><span class="s2">_triv = </span><span class="si">{</span><span class="n">_fmt_mean_euc_with_geo_pi</span><span class="p">(</span><span class="n">eps_triv_mean</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">_tline</span><span class="p">(</span>
                    <span class="s2">&quot;surjectivity defect:&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;δ := sup_{(i j k)∈N(U)} min_{v∈{i,j,k}} d_H(f_v(π^{-1}(U_i∩U_j∩U_k)), S^1)&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; = </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;stability ratio:&quot;</span><span class="p">,</span> <span class="s2">&quot;α := ε_triv/(1-δ) = ∞  (since δ ≥ 1)&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;stability ratio:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;α := ε_triv/(1-δ) = </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">eps_coc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">_tline</span><span class="p">(</span>
                    <span class="s2">&quot;cocycle error:&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ε_coc := sup_{(i j k)∈N(U)} ‖Ω_</span><span class="si">{ij}</span><span class="s2">Ω_</span><span class="si">{jk}</span><span class="s2">Ω_</span><span class="si">{ki}</span><span class="s2"> - I‖_F&quot;</span> <span class="sa">f</span><span class="s2">&quot; = </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">eps_coc</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;Euler rounding diag:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;d_∞(δ_ω θ, ẽ) = </span><span class="si">{</span><span class="n">rounding_dist</span><span class="si">:</span><span class="s2">.6g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>

    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;=== Characteristic Classes ===&quot;</span><span class="p">)</span>
    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">_tline</span><span class="p">(</span>
            <span class="s2">&quot;Stiefel–Whitney:&quot;</span><span class="p">,</span>
            <span class="s2">&quot;w₁ = 0 (orientable)&quot;</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">w1_is_cob</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;w₁ ≠ 0 (non-orientable)&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">n_tri</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;Euler class:&quot;</span><span class="p">,</span> <span class="s2">&quot;0 (no 2-simplices)&quot;</span><span class="p">))</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">did_latex</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;latex&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">}:</span>
                <span class="n">did_latex</span> <span class="o">=</span> <span class="n">_display_summary_latex</span><span class="p">(</span>
                    <span class="n">classes</span><span class="p">,</span>
                    <span class="n">quality</span><span class="o">=</span><span class="n">quality</span><span class="p">,</span>
                    <span class="n">rounding_dist</span><span class="o">=</span><span class="n">rounding_dist</span><span class="p">,</span>
                    <span class="n">e_zero_for_print</span><span class="o">=</span><span class="n">e_zero_for_print</span><span class="p">,</span>
                    <span class="n">w1_is_zero</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">w1_is_cob</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">did_latex</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># Euler class / Euler number reporting (per your rules)</span>
    <span class="c1"># ------------------------------------------------------------</span>

    <span class="c1"># (1) Euler class trivial -&gt; always report Euler class, never Euler number.</span>
    <span class="k">if</span> <span class="n">e_zero_for_print</span><span class="p">:</span>
        <span class="n">bt</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;bundle_trivial_on_this_complex&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orientable</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;Euler class:&quot;</span><span class="p">,</span> <span class="s2">&quot;e = 0 (trivial)&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;(twisted) Euler class:&quot;</span><span class="p">,</span> <span class="s2">&quot;ẽ = 0&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">bt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;bundle trivial:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">bool</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">did_latex</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;latex&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">}:</span>
                <span class="n">did_latex</span> <span class="o">=</span> <span class="n">_display_summary_latex</span><span class="p">(</span>
                    <span class="n">classes</span><span class="p">,</span>
                    <span class="n">quality</span><span class="o">=</span><span class="n">quality</span><span class="p">,</span>
                    <span class="n">rounding_dist</span><span class="o">=</span><span class="n">rounding_dist</span><span class="p">,</span>
                    <span class="n">e_zero_for_print</span><span class="o">=</span><span class="n">e_zero_for_print</span><span class="p">,</span>
                    <span class="n">w1_is_zero</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">w1_is_cob</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">did_latex</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="c1"># From here on, Euler class is nontrivial.</span>

    <span class="c1"># (2) Euler class nontrivial + Euler number available -&gt; report ONLY Euler number (no Euler class line).</span>
    <span class="k">if</span> <span class="n">eZ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">eZ</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">orientable</span><span class="p">:</span>
            <span class="n">parity_note</span> <span class="o">=</span> <span class="s2">&quot; (spin)&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot; (not spin)&quot;</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;Euler number:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;±</span><span class="si">{</span><span class="n">k</span><span class="si">}{</span><span class="n">parity_note</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;(twisted) Euler number:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;±</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># (3) Euler class nontrivial + Euler number unavailable -&gt; report Euler class nontrivial,</span>
        <span class="c1">#     and (orientable only) report spin class fallback when available.</span>
        <span class="k">if</span> <span class="n">orientable</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;Euler class:&quot;</span><span class="p">,</span> <span class="s2">&quot;e ≠ 0 (non-trivial)&quot;</span><span class="p">))</span>
            <span class="n">w2_is_zero</span> <span class="o">=</span> <span class="n">_infer_w2_is_zero</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">w2_is_zero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">_tline</span><span class="p">(</span>
                        <span class="s2">&quot;Spin class:&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;w₂ = 0 (spin)&quot;</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">w2_is_zero</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;w₂ ≠ 0 (not spin)&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;(twisted) Euler class:&quot;</span><span class="p">,</span> <span class="s2">&quot;ẽ ≠ 0&quot;</span><span class="p">))</span>

    <span class="n">bt</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;bundle_trivial_on_this_complex&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tline</span><span class="p">(</span><span class="s2">&quot;bundle trivial:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">bool</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>

    <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">did_latex</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;latex&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">}:</span>
            <span class="n">did_latex</span> <span class="o">=</span> <span class="n">_display_summary_latex</span><span class="p">(</span>
                <span class="n">classes</span><span class="p">,</span>
                <span class="n">quality</span><span class="o">=</span><span class="n">quality</span><span class="p">,</span>
                <span class="n">rounding_dist</span><span class="o">=</span><span class="n">rounding_dist</span><span class="p">,</span>
                <span class="n">e_zero_for_print</span><span class="o">=</span><span class="n">e_zero_for_print</span><span class="p">,</span>
                <span class="n">w1_is_zero</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">w1_is_cob</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">did_latex</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">text</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_display_summary_latex</span><span class="p">(</span>
    <span class="n">classes</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">quality</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rounding_dist</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">e_zero_for_print</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">w1_is_zero</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Best-effort IPython Math display (user-facing formatting).</span>

<span class="sd">    Rules:</span>
<span class="sd">    - No explicit pairings shown.</span>
<span class="sd">    - Euler number is displayed as:</span>
<span class="sd">        * orientable:     &quot;Euler number: k (spin/not spin)&quot;  (no &quot;e =&quot;)</span>
<span class="sd">        * non-orientable: &quot;(twisted) Euler number: k&quot;        (no &quot;\\tilde{e} =&quot;)</span>
<span class="sd">    - Reporting rules:</span>
<span class="sd">        * If (twisted) Euler class is trivial: report Euler class line and do NOT report Euler number.</span>
<span class="sd">        * If (twisted) Euler class is nontrivial and Euler number is available: report ONLY Euler number.</span>
<span class="sd">        * If orientable and Euler class is nontrivial but Euler number undefined: report Euler class + spin class fallback.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">display</span><span class="p">,</span> <span class="n">Math</span>  <span class="c1"># type: ignore</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># Pull diagnostics</span>
    <span class="c1"># ----------------------------</span>
    <span class="n">eps_triv</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;eps_align_euc&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">eps_triv_mean</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;eps_align_euc_mean&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;delta&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">eps_coc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s2">&quot;cocycle_defect&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># Class quantities</span>
    <span class="c1"># ----------------------------</span>
    <span class="n">orientable</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;orientable&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    <span class="n">n_tri</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;n_triangles&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">eZ</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;twisted_euler_number_Z&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_infer_w2_is_zero</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;spin_on_this_complex&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

        <span class="n">sw2</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="s2">&quot;sw2_Z2&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sw2</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sw2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sw2</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># helpers for latex numeric strings with geo-in-π parentheses</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_latex_eps_with_geo_pi</span><span class="p">(</span><span class="n">d_euc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">decimals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">mean</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">d_euc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">d_euc</span><span class="p">)):</span>
            <span class="k">return</span> <span class="sa">r</span><span class="s2">&quot;\text{—}&quot;</span>
        <span class="n">d_euc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">d_euc</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">_euc_to_geo_rad</span><span class="p">(</span><span class="n">d_euc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d_euc</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">mean</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d_euc</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\ \left(\bar{\varepsilon}_{\text</span><span class="si">{triv}</span><span class="s2">}^{\text</span><span class="si">{geo}</span><span class="s2">}=&quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">theta</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\pi\right)&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d_euc</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\ \left(\varepsilon_{\text</span><span class="si">{triv}</span><span class="s2">}^{\text</span><span class="si">{geo}</span><span class="s2">}=&quot;</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">theta</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimals</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\pi\right)&quot;</span>
        <span class="p">)</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># Rows</span>
    <span class="c1"># ----------------------------</span>
    <span class="n">diag_rows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">diag_rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\text{(no quality report provided)}&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">eps_triv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diag_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;\text{Trivialization error}&quot;</span><span class="p">,</span>
                    <span class="sa">r</span><span class="s2">&quot;\varepsilon_{\text</span><span class="si">{triv}</span><span class="s2">} := &quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;\sup_{(j\,k)\in\mathcal</span><span class="si">{N}</span><span class="s2">(\mathcal</span><span class="si">{U}</span><span class="s2">)}\sup_{x\in\pi^{-1}(U_j\cap U_k)} &quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;d_{\mathbb</span><span class="si">{C}</span><span class="s2">}(\Omega_</span><span class="si">{jk}</span><span class="s2">f_k(x),f_j(x))&quot;</span>
                    <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; = &quot;</span>
                    <span class="o">+</span> <span class="n">_latex_eps_with_geo_pi</span><span class="p">(</span><span class="n">eps_triv</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">eps_triv_mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diag_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;\text{Mean triv error}&quot;</span><span class="p">,</span>
                    <span class="sa">r</span><span class="s2">&quot;\bar{\varepsilon}_{\text</span><span class="si">{triv}</span><span class="s2">}&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="n">_latex_eps_with_geo_pi</span><span class="p">(</span><span class="n">eps_triv_mean</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diag_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;\text{Surjectivity defect}&quot;</span><span class="p">,</span>
                    <span class="sa">r</span><span class="s2">&quot;\delta := \sup_{(i\,j\,k)\in\mathcal</span><span class="si">{N}</span><span class="s2">(\mathcal</span><span class="si">{U}</span><span class="s2">)}\min_{v\in\{i,j,k\}} &quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;d_H\!\left(f_v(\pi^{-1}(U_i\cap U_j\cap U_k)),\mathbb</span><span class="si">{S}</span><span class="s2">^1\right)&quot;</span>
                    <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; = &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
                <span class="n">diag_rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\text{Stability ratio}&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\alpha := \varepsilon_{\text</span><span class="si">{triv}</span><span class="s2">}/(1-\delta) = \infty&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diag_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="sa">r</span><span class="s2">&quot;\text{Stability ratio}&quot;</span><span class="p">,</span>
                        <span class="sa">r</span><span class="s2">&quot;\alpha := \varepsilon_{\text</span><span class="si">{triv}</span><span class="s2">}/(1-\delta) = &quot;</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">eps_coc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diag_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;\text{Cocycle error}&quot;</span><span class="p">,</span>
                    <span class="sa">r</span><span class="s2">&quot;\varepsilon_{\mathrm</span><span class="si">{coc}</span><span class="s2">} := &quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;\sup_{(i\,j\,k)\in\mathcal</span><span class="si">{N}</span><span class="s2">(\mathcal</span><span class="si">{U}</span><span class="s2">)}\left\|\Omega_</span><span class="si">{ij}</span><span class="s2">\Omega_</span><span class="si">{jk}</span><span class="s2">\Omega_</span><span class="si">{ki}</span><span class="s2">-I\right\|_F&quot;</span>
                    <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; = &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">eps_coc</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">diag_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;\text{Euler rounding dist.}&quot;</span><span class="p">,</span>
                <span class="sa">r</span><span class="s2">&quot;d_\infty(\delta_\omega\theta,\tilde</span><span class="si">{e}</span><span class="s2">) = &quot;</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">rounding_dist</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="n">class_rows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">class_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;\text{Stiefel--Whitney}&quot;</span><span class="p">,</span>
            <span class="sa">r</span><span class="s2">&quot;w_1 = 0\ (\text</span><span class="si">{orientable}</span><span class="s2">)&quot;</span> <span class="k">if</span> <span class="n">w1_is_zero</span> <span class="k">else</span> <span class="sa">r</span><span class="s2">&quot;w_1 \neq 0\ (\text{non-orientable})&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">n_tri</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">class_rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\text{Euler class}&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;e = 0\ \text{(no 2-simplices)}&quot;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># Euler class / Euler number reporting (per your rules)</span>
        <span class="c1"># ------------------------------------------------------------</span>

        <span class="k">if</span> <span class="n">e_zero_for_print</span><span class="p">:</span>
            <span class="c1"># Euler class trivial -&gt; always report Euler class, never Euler number</span>
            <span class="k">if</span> <span class="n">orientable</span><span class="p">:</span>
                <span class="n">class_rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\text{Euler class}&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;e = 0\ (\text</span><span class="si">{trivial}</span><span class="s2">)&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">class_rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\text{(twisted) Euler class}&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\tilde</span><span class="si">{e}</span><span class="s2"> = 0&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Euler class nontrivial</span>
            <span class="k">if</span> <span class="n">eZ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Euler number available -&gt; report ONLY Euler number (no Euler class line)</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">eZ</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">orientable</span><span class="p">:</span>
                    <span class="n">parity_note</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\ (\text</span><span class="si">{spin}</span><span class="s2">)&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="sa">r</span><span class="s2">&quot;\ (\text{not spin})&quot;</span>
                    <span class="n">class_rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\text{Euler number}&quot;</span><span class="p">,</span> <span class="sa">rf</span><span class="s2">&quot;\pm </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">parity_note</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">class_rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\text{(twisted) Euler number}&quot;</span><span class="p">,</span> <span class="sa">rf</span><span class="s2">&quot;\pm </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Euler number unavailable -&gt; report Euler class nontrivial (+ spin fallback if available)</span>
                <span class="k">if</span> <span class="n">orientable</span><span class="p">:</span>
                    <span class="n">class_rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\text{Euler class}&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;e \neq 0\ (\text{non-trivial})&quot;</span><span class="p">))</span>
                    <span class="n">w2_is_zero</span> <span class="o">=</span> <span class="n">_infer_w2_is_zero</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">w2_is_zero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">class_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="sa">r</span><span class="s2">&quot;\text{Spin class}&quot;</span><span class="p">,</span>
                                <span class="sa">r</span><span class="s2">&quot;w_2 = 0\ (\text</span><span class="si">{spin}</span><span class="s2">)&quot;</span>
                                <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">w2_is_zero</span><span class="p">)</span>
                                <span class="k">else</span> <span class="sa">r</span><span class="s2">&quot;w_2 \neq 0\ (\text{not spin})&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">class_rows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\text{(twisted) Euler class}&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\tilde</span><span class="si">{e}</span><span class="s2"> \neq 0&quot;</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rows_to_aligned</span><span class="p">(</span><span class="n">rows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\quad &quot;</span> <span class="o">+</span> <span class="n">label</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; &amp;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\quad &quot;</span> <span class="o">+</span> <span class="n">label</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot; &amp;:\quad &quot;</span> <span class="o">+</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">[3pt]&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="n">latex</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">r</span><span class="s2">&quot;\begin</span><span class="si">{aligned}</span><span class="s2">&quot;</span>
        <span class="sa">r</span><span class="s2">&quot;\textbf</span><span class="si">{Diagnostics}</span><span class="s2"> &amp; </span><span class="se">\\</span><span class="s2">[6pt]&quot;</span>
        <span class="o">+</span> <span class="n">_rows_to_aligned</span><span class="p">(</span><span class="n">diag_rows</span><span class="p">)</span>
        <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">[14pt]&quot;</span>
        <span class="sa">r</span><span class="s2">&quot;\textbf{Characteristic Classes} &amp; </span><span class="se">\\</span><span class="s2">[6pt]&quot;</span>
        <span class="o">+</span> <span class="n">_rows_to_aligned</span><span class="p">(</span><span class="n">class_rows</span><span class="p">)</span>
        <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\end</span><span class="si">{aligned}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">display</span><span class="p">(</span><span class="n">Math</span><span class="p">(</span><span class="n">latex</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, Brad Turow.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>