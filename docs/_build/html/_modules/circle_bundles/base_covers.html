

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>circle_bundles.base_covers &mdash; circle_bundles 0+unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/myst_sphinx_gallery.css?v=92de7a9e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=27db1736"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            circle_bundles
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#basic-installation">Basic installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#optional-dependencies">Optional dependencies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#minimal-working-example">Minimal working example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#notes">Notes</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../theory/index.html">Theory</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/core_pipeline.html">Core pipeline</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.build_bundle.html">circle_bundles.build_bundle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.BundleResult.html">circle_bundles.BundleResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.DreimacCCConfig.html">circle_bundles.DreimacCCConfig</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.LocalTrivResult.html">circle_bundles.LocalTrivResult</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/covers.html">Covers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.MetricBallCover.html">circle_bundles.MetricBallCover</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.TriangulationStarCover.html">circle_bundles.TriangulationStarCover</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.make_s2_fibonacci_star_cover.html">circle_bundles.make_s2_fibonacci_star_cover</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.make_rp2_fibonacci_star_cover.html">circle_bundles.make_rp2_fibonacci_star_cover</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/metrics.html">Metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.EuclideanMetric.html">circle_bundles.EuclideanMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.S1AngleMetric.html">circle_bundles.S1AngleMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.RP1AngleMetric.html">circle_bundles.RP1AngleMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.S1UnitVectorMetric.html">circle_bundles.S1UnitVectorMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.RP1UnitVectorMetric.html">circle_bundles.RP1UnitVectorMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.RP2UnitVectorMetric.html">circle_bundles.RP2UnitVectorMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.T2FlatMetric.html">circle_bundles.T2FlatMetric</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/characteristic_classes.html">Characteristic classes and transitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.O2Cocycle.html">circle_bundles.O2Cocycle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.TransitionReport.html">circle_bundles.TransitionReport</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.ClassResult.html">circle_bundles.ClassResult</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/coordinatization.html">Coordinatization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.GlobalTrivializationResult.html">circle_bundles.GlobalTrivializationResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.BundleMapResult.html">circle_bundles.BundleMapResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.PullbackTotalSpaceResult.html">circle_bundles.PullbackTotalSpaceResult</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/weights_filtration.html">Weights filtration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.PersistenceResult.html">circle_bundles.PersistenceResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.CobirthResult.html">circle_bundles.CobirthResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.CodeathResult.html">circle_bundles.CodeathResult</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.MaxTrivialSubcomplex.html">circle_bundles.MaxTrivialSubcomplex</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/analysis.html">Analysis utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.fiberwise_clustering.html">circle_bundles.fiberwise_clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_cluster_persistence.html">circle_bundles.get_cluster_persistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_filtered_cluster_graph.html">circle_bundles.get_filtered_cluster_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_local_pca.html">circle_bundles.get_local_pca</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_local_pca.html">circle_bundles.plot_local_pca</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_local_rips.html">circle_bundles.get_local_rips</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_local_rips.html">circle_bundles.plot_local_rips</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_fiberwise_pca_grid.html">circle_bundles.plot_fiberwise_pca_grid</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_fiberwise_summary_bars.html">circle_bundles.plot_fiberwise_summary_bars</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_cocycle_dict.html">circle_bundles.get_cocycle_dict</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.lift_base_points.html">circle_bundles.lift_base_points</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../extras/index.html">Extras and utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../extras/synthetic.html">Synthetic datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/viz.html">Visualization Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/optical_flow.html">Optical Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/special_metrics.html">Specialized and quotient metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.Torus_DiagQuotientMetric_R4.html">circle_bundles.Torus_DiagQuotientMetric_R4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.Torus_KleinQuotientMetric_R4.html">circle_bundles.Torus_KleinQuotientMetric_R4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.RP2_TrivialMetric.html">circle_bundles.RP2_TrivialMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.RP2_TwistMetric.html">circle_bundles.RP2_TwistMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.RP2_FlipMetric.html">circle_bundles.RP2_FlipMetric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../extras/generated/circle_bundles.S3QuotientMetric.html">circle_bundles.S3QuotientMetric</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/index.html">Tutorials</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/index.html">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/optical_flow/index.html">Optical Flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/quotients/index.html">Quotients</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/index.html#core">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/index.html#optical-flow">Optical Flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/index.html#quotients">Quotients</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">circle_bundles</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">circle_bundles.base_covers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for circle_bundles.base_covers</h1><div class="highlight"><pre>
<span></span><span class="c1"># covers.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">EuclideanMetric</span><span class="p">,</span> <span class="n">as_metric</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.geometry.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_bary_coords</span><span class="p">,</span> <span class="n">points_in_triangle_mask</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.nerve.combinatorics</span><span class="w"> </span><span class="kn">import</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">Tri</span><span class="p">,</span> <span class="n">canon_edge</span><span class="p">,</span> <span class="n">canon_tri</span>


<span class="n">Tet</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">canon_tet</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tet</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">))))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_as_2d_points</span><span class="p">(</span><span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;points&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> must be 1D or 2D. Got shape </span><span class="si">{</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


<span class="c1"># ----------------------------</span>
<span class="c1"># Nerve summary data container</span>
<span class="c1"># ----------------------------</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NerveSummary</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary of a cover and the recorded nerve up to dimension 3.</span>

<span class="sd">    This container is produced by :meth:`CoverBase.summarize` and is intended to be</span>
<span class="sd">    lightweight: it stores basic counts, optional intersection cardinalities, and</span>
<span class="sd">    optional evidence about higher-order overlaps detected directly from the cover</span>
<span class="sd">    membership matrix ``U``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The library may only *record* simplices up to dimension 3 (tetrahedra), but</span>
<span class="sd">      the underlying cover matrix ``U`` can still contain higher-order overlaps.</span>
<span class="sd">      When detected (sample overlap order ≥ 5), the summary exposes:</span>
<span class="sd">        - ``max_overlap_order`` and</span>
<span class="sd">        - ``n_samples_with_overlap_ge_5``</span>
<span class="sd">      and typically includes warnings about the mismatch.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    n_sets :</span>
<span class="sd">        Number of cover sets.</span>
<span class="sd">    n_samples :</span>
<span class="sd">        Number of samples/points covered.</span>

<span class="sd">    n0, n1, n2, n3 :</span>
<span class="sd">        Recorded simplex counts in dimensions 0..3.</span>

<span class="sd">    vert_card, edge_card, tri_card, tet_card :</span>
<span class="sd">        Optional intersection cardinalities for recorded simplices, i.e.</span>
<span class="sd">        ``|⋂_{i in σ} U_i|`` for each recorded simplex ``σ``.</span>
<span class="sd">        Shapes are ``(n0,)``, ``(n1,)``, ``(n2,)``, ``(n3,)`` respectively</span>
<span class="sd">        when present.</span>

<span class="sd">    sample_overlap_counts :</span>
<span class="sd">        For each sample ``s``, the number of cover sets containing it, i.e.</span>
<span class="sd">        ``(# of i with U[i,s] = True)``. Shape ``(n_samples,)``.</span>

<span class="sd">    max_overlap_order :</span>
<span class="sd">        Only populated when the maximum sample overlap order exceeds 4.</span>
<span class="sd">        In that case this is ``max(sample_overlap_counts)``.</span>
<span class="sd">    n_samples_with_overlap_ge_5 :</span>
<span class="sd">        Only populated when ``max_overlap_order`` is set. Counts samples lying</span>
<span class="sd">        in 5 or more cover sets.</span>

<span class="sd">    warnings :</span>
<span class="sd">        Tuple of human-readable warning strings surfaced by :meth:`summarize`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_sets</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span>

    <span class="c1"># recorded simplex counts (what the cover reports)</span>
    <span class="n">n0</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n1</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n2</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">n3</span><span class="p">:</span> <span class="nb">int</span>

    <span class="c1"># intersection cardinalities (#samples in ⋂ U_i) for recorded simplices</span>
    <span class="n">vert_card</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (n0,)</span>
    <span class="n">edge_card</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (n1,)</span>
    <span class="n">tri_card</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># (n2,)</span>
    <span class="n">tet_card</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># (n3,)</span>

    <span class="c1"># overlap order per sample: how many cover sets contain each sample</span>
    <span class="n">sample_overlap_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (n_samples,)</span>

    <span class="c1"># only surfaced when &gt; 4</span>
    <span class="n">max_overlap_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">n_samples_with_overlap_ge_5</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">warnings</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

    <span class="c1"># ---- pretty formatting ----</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_text</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Human-readable, terminal-friendly summary.</span>

<span class="sd">        Policy:</span>
<span class="sd">          - If max_overlap_order &gt; 4, we print ALL recorded counts for dims 0..3</span>
<span class="sd">            (even if some are zero), because mismatch is meaningful.</span>
<span class="sd">          - Otherwise, we print counts only up to the last nonzero recorded dim,</span>
<span class="sd">            then a single line noting higher dims are zero.</span>
<span class="sd">          - We only show overlap-order lines if max_overlap_order &gt; 4.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Cover And Nerve Summary&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  n_sets = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="si">}</span><span class="s2">, n_samples = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n0</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n1</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n2</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n3</span><span class="p">)}</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_overlap_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_overlap_order</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  recorded simplex counts:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    #( </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">-simplices ) = </span><span class="si">{</span><span class="n">counts</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  overlap evidence from U:&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    max sample overlap order = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_overlap_order</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    samples in ≥5 sets = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples_with_overlap_ge_5</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Truncate at last nonzero recorded dimension</span>
            <span class="n">last_nonzero</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">last_nonzero</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="k">break</span>

            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  recorded simplex counts:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_nonzero</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    #( </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">-simplices ) = </span><span class="si">{</span><span class="n">counts</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">last_nonzero</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    no recorded simplices in dimensions ≥ </span><span class="si">{</span><span class="n">last_nonzero</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  WARNING: </span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_markdown</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Markdown + LaTeX-ish version for notebooks.</span>
<span class="sd">        (Uses inline math; renders nicely in Jupyter.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n0</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n1</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n2</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n3</span><span class="p">)}</span>
        <span class="n">md</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;### Cover And Nerve Summary&quot;</span><span class="p">)</span>
        <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- $n_</span><span class="se">\\</span><span class="s2">text</span><span class="se">{{</span><span class="s2">sets</span><span class="se">}}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="si">}</span><span class="s2">$, $n_</span><span class="se">\\</span><span class="s2">text</span><span class="se">{{</span><span class="s2">samples</span><span class="se">}}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="si">}</span><span class="s2">$&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_overlap_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_overlap_order</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;**Recorded Simplex Counts:**&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="sa">f</span><span class="s2">&quot;- $</span><span class="se">\\</span><span class="s2">#(</span><span class="se">\\</span><span class="s2">text</span><span class="se">{{</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">-simplices</span><span class="se">}}</span><span class="s2">) = </span><span class="si">{</span><span class="n">counts</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="si">}</span><span class="s2">$&quot;</span>
                        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;**Overlap evidence from $U$:**&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- $</span><span class="se">\\</span><span class="s2">max_s </span><span class="se">\\</span><span class="s2">sum_i U_</span><span class="se">{{</span><span class="s2">i,s</span><span class="se">}}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_overlap_order</span><span class="si">}</span><span class="s2">$&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- $</span><span class="se">\\</span><span class="s2">#</span><span class="se">\\{{</span><span class="s2">s : </span><span class="se">\\</span><span class="s2">sum_i U_</span><span class="se">{{</span><span class="s2">i,s</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">ge 5</span><span class="se">\\}}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples_with_overlap_ge_5</span><span class="si">}</span><span class="s2">$&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">last_nonzero</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">last_nonzero</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="k">break</span>

            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;**Recorded Simplex Counts:**&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;- $</span><span class="se">\\</span><span class="s2">#(</span><span class="se">\\</span><span class="s2">text</span><span class="se">{{</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">-simplices</span><span class="se">}}</span><span class="s2">) = </span><span class="si">{</span><span class="n">counts</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="si">}</span><span class="s2">$&quot;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_nonzero</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">last_nonzero</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- *No recorded simplices in dimensions* $</span><span class="se">\\</span><span class="s2">ge </span><span class="si">{</span><span class="n">last_nonzero</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">$&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span><span class="p">:</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;**Warnings:**&quot;</span><span class="p">)</span>
            <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span><span class="p">:</span>
                <span class="n">md</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- </span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>


<span class="c1"># ----------------------------</span>
<span class="c1"># Internal helpers (summary)</span>
<span class="c1"># ----------------------------</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_simplex_intersection_cardinality</span><span class="p">(</span><span class="n">U</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cardinality (#samples) of ⋂_{i in sig} U_i.  U: (n_sets, n_samples) bool.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_cards_for_simplices</span><span class="p">(</span><span class="n">U</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">simplices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute intersection cardinalities for a list of simplices.&quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">simplices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sig</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">simplices</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_simplex_intersection_cardinality</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_try_display_markdown</span><span class="p">(</span><span class="n">md</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Try to display markdown in a notebook. Returns True if it displayed, else False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">display</span><span class="p">,</span> <span class="n">Markdown</span>  <span class="c1"># type: ignore</span>
        <span class="n">display</span><span class="p">(</span><span class="n">Markdown</span><span class="p">(</span><span class="n">md</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="c1"># ----------------------------</span>
<span class="c1"># Plot helpers (box-and-whisker)</span>
<span class="c1"># ----------------------------</span>

<span class="k">def</span><span class="w"> </span><span class="nf">plot_cover_summary_boxplot</span><span class="p">(</span>
    <span class="n">summary</span><span class="p">:</span> <span class="n">NerveSummary</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">show_tets</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dpi</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">figsize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">save_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">showfliers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">whis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
    <span class="n">sharey</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">label_fmt</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:g}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">label_dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.06</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot intersection cardinalities for recorded nerve simplices.</span>

<span class="sd">    Produces a 1×k grid of box-and-whisker plots for the cardinalities:</span>

<span class="sd">    - 0-simplices: ``|U_i|`` (when available)</span>
<span class="sd">    - 1-simplices: ``|U_i ∩ U_j|``</span>
<span class="sd">    - 2-simplices: ``|U_i ∩ U_j ∩ U_k|``</span>
<span class="sd">    - 3-simplices: ``|U_i ∩ U_j ∩ U_k ∩ U_ℓ|`` (optional)</span>

<span class="sd">    By default, whiskers use the full range ``whis=(0,100)`` so min/max are the</span>
<span class="sd">    actual extrema (not outlier-based). The plot annotates min/max next to the</span>
<span class="sd">    whiskers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    summary :</span>
<span class="sd">        A :class:`NerveSummary` produced by :meth:`CoverBase.summarize` with</span>
<span class="sd">        cardinalities computed.</span>
<span class="sd">    show_tets :</span>
<span class="sd">        If True, include the 3-simplex panel when ``summary.tet_card`` is present.</span>
<span class="sd">    dpi :</span>
<span class="sd">        Figure DPI.</span>
<span class="sd">    figsize :</span>
<span class="sd">        Optional figure size. If omitted, a width proportional to the number of</span>
<span class="sd">        panels is chosen.</span>
<span class="sd">    save_path :</span>
<span class="sd">        Optional output prefix. If provided, saves a PDF named</span>
<span class="sd">        ``&lt;save_path&gt;_cover_summary.pdf``.</span>
<span class="sd">    showfliers :</span>
<span class="sd">        Whether to show fliers in the boxplot.</span>
<span class="sd">    whis :</span>
<span class="sd">        Whisker definition passed to ``matplotlib.axes.Axes.boxplot``.</span>
<span class="sd">        Default ``(0,100)`` gives true min/max.</span>
<span class="sd">    sharey :</span>
<span class="sd">        Share the y-axis across panels.</span>
<span class="sd">    label_fmt :</span>
<span class="sd">        Format string used for min/max labels.</span>
<span class="sd">    label_dx :</span>
<span class="sd">        Horizontal label offset (currently expressed as a small shift in x data units).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fig, ax_or_axes :</span>
<span class="sd">        ``(fig, ax)`` if only one panel is drawn, otherwise ``(fig, axes_list)``.</span>
<span class="sd">        Returns ``(None, None)`` if no panels are available.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is designed for quick diagnostics. For publication-style plots,</span>
<span class="sd">    you may want custom axis limits, log scaling, or annotated quantiles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

    <span class="n">panels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">summary</span><span class="p">,</span> <span class="s2">&quot;vert_card&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">summary</span><span class="o">.</span><span class="n">vert_card</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">panels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">summary</span><span class="o">.</span><span class="n">vert_card</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="sa">r</span><span class="s2">&quot;$0$-Simplices: $|U_i|$&quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">summary</span><span class="o">.</span><span class="n">edge_card</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">summary</span><span class="o">.</span><span class="n">edge_card</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">panels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">summary</span><span class="o">.</span><span class="n">edge_card</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="sa">r</span><span class="s2">&quot;$1$-Simplices: $|U_i \cap U_j|$&quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">summary</span><span class="o">.</span><span class="n">tri_card</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">summary</span><span class="o">.</span><span class="n">tri_card</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">panels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">summary</span><span class="o">.</span><span class="n">tri_card</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="sa">r</span><span class="s2">&quot;$2$-Simplices: $|U_i \cap U_j \cap U_k|$&quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">show_tets</span> <span class="ow">and</span> <span class="p">(</span><span class="n">summary</span><span class="o">.</span><span class="n">tet_card</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">summary</span><span class="o">.</span><span class="n">tet_card</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">panels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">summary</span><span class="o">.</span><span class="n">tet_card</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="sa">r</span><span class="s2">&quot;$3$-Simplices: $|U_i \cap U_j \cap U_k \cap U_\ell|$&quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">panels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">panels</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">figsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">)</span>

    <span class="c1"># Using constrained_layout tends to behave better than tight_layout for annotated plots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
        <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
        <span class="n">dpi</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">dpi</span><span class="p">),</span>
        <span class="n">sharey</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">sharey</span><span class="p">),</span>
        <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">axes_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes_list</span><span class="p">,</span> <span class="n">panels</span><span class="p">):</span>
        <span class="c1"># One box per panel</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span>
            <span class="p">[</span><span class="n">arr</span><span class="p">],</span>
            <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span>
            <span class="n">showfliers</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">showfliers</span><span class="p">),</span>
            <span class="n">whis</span><span class="o">=</span><span class="n">whis</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># --- Grab whisker endpoints from the artists (robust, respects whis) ---</span>
        <span class="c1"># bp[&quot;whiskers&quot;] has 2 Line2D objects: lower and upper whiskers</span>
        <span class="n">w0</span><span class="p">,</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">bp</span><span class="p">[</span><span class="s2">&quot;whiskers&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bp</span><span class="p">[</span><span class="s2">&quot;whiskers&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">y0</span> <span class="o">=</span> <span class="n">w0</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">w1</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
        <span class="n">low</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">]))</span>
        <span class="n">high</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">]))</span>

        <span class="c1"># x position: whiskers are at x=1; place text slightly to the right.</span>
        <span class="c1"># We&#39;ll offset in *axes-fraction* to be stable across panels.</span>
        <span class="n">x_whisk</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">x_text</span> <span class="o">=</span> <span class="n">x_whisk</span> <span class="o">+</span> <span class="mf">0.03</span>  <span class="c1"># in data coords; OK since x-range is tiny</span>

        <span class="c1"># Put labels beside the whisker endpoints, centered vertically on the endpoint</span>
        <span class="n">tmax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
            <span class="n">x_text</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;max = </span><span class="si">{</span><span class="n">label_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">high</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
            <span class="n">clip_on</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">tmin</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
            <span class="n">x_text</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;min = </span><span class="si">{</span><span class="n">label_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">low</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
            <span class="n">clip_on</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Critical: don&#39;t let these annotations affect layout engines</span>
        <span class="c1"># (prevents giant whitespace + &quot;tight layout not applied&quot; warnings)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tmax</span><span class="o">.</span><span class="n">set_in_layout</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tmin</span><span class="o">.</span><span class="n">set_in_layout</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Ensure enough x-room so labels aren&#39;t clipped on the right</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.35</span><span class="p">)</span>

        <span class="c1"># Small y padding so text isn&#39;t sitting on the border</span>
        <span class="n">ypad</span> <span class="o">=</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">low</span> <span class="o">-</span> <span class="n">ypad</span><span class="p">,</span> <span class="n">high</span> <span class="o">+</span> <span class="n">ypad</span><span class="p">)</span>

    <span class="n">axes_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Intersection Cardinality (#Samples)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">save_path</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.pdf&quot;</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_cover_summary.pdf&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="s2">&quot;_cover_summary.pdf&quot;</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">axes_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">axes_list</span><span class="p">)</span>



<span class="c1"># ----------------------------</span>
<span class="c1"># Base cover API</span>
<span class="c1"># ----------------------------</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CoverBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for covers over a set of base points.</span>

<span class="sd">    A cover is represented primarily by a boolean membership matrix ``U`` with shape</span>
<span class="sd">    ``(n_sets, n_samples)``, where ``U[i,s]`` indicates whether sample ``s`` lies in</span>
<span class="sd">    cover set ``U_i``. Most workflows also use a partition of unity ``pou`` of the</span>
<span class="sd">    same shape.</span>

<span class="sd">    Subclasses implement :meth:`build` to populate ``U`` and ``pou``, and implement</span>
<span class="sd">    the nerve accessors (:meth:`nerve_edges`, :meth:`nerve_triangles`, optionally</span>
<span class="sd">    :meth:`nerve_tetrahedra`) to report recorded simplices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base_points :</span>
<span class="sd">        Array of shape ``(n_samples, dB)`` giving base coordinates for each sample.</span>
<span class="sd">        One-dimensional inputs are reshaped to ``(n_samples, 1)``.</span>
<span class="sd">    U :</span>
<span class="sd">        Optional boolean membership matrix of shape ``(n_sets, n_samples)``.</span>
<span class="sd">        If not provided, subclasses compute it in :meth:`build`.</span>
<span class="sd">    pou :</span>
<span class="sd">        Optional partition of unity weights of shape ``(n_sets, n_samples)``.</span>
<span class="sd">        Typically satisfies ``pou[:,s].sum() == 1`` for each sample ``s`` (when covered).</span>
<span class="sd">    landmarks :</span>
<span class="sd">        Optional landmark coordinates of shape ``(n_sets, dB)`` used for visualization</span>
<span class="sd">        and for some cover constructions (e.g. metric ball covers).</span>
<span class="sd">    metric :</span>
<span class="sd">        Distance model used by the cover (for constructions that require it).</span>
<span class="sd">        May be a Metric object with ``pairwise`` or a scalar callable; it is normalized</span>
<span class="sd">        by :meth:`ensure_metric`.</span>
<span class="sd">    full_dist_mat :</span>
<span class="sd">        Optional cached sample-sample distance matrix for visualization.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    base_name, base_name_latex :</span>
<span class="sd">        Optional base labels used in plots and summaries. If not set explicitly,</span>
<span class="sd">        :meth:`ensure_metric` will inherit these from the metric object when available.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Most downstream algorithms expect ``U`` and ``pou`` to be populated.</span>
<span class="sd">      Use :meth:`ensure_built` to build lazily.</span>
<span class="sd">    - The “recorded nerve” is whatever simplices the cover reports via</span>
<span class="sd">      ``nerve_edges/nerve_triangles/...``. It may be truncated even if ``U``</span>
<span class="sd">      contains higher-order overlaps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>                 <span class="c1"># (n_samples, dB)</span>
    <span class="n">U</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>          <span class="c1"># (n_sets, n_samples) bool</span>
    <span class="n">pou</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>        <span class="c1"># (n_sets, n_samples) float</span>
    <span class="n">landmarks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (n_sets, dB) float</span>
    <span class="n">metric</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>                 <span class="c1"># should be a Metric object (has .pairwise)</span>
    <span class="n">full_dist_mat</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># optional cache for viz</span>

<span class="c1"># --- optional metadata for summaries/plots ---</span>
    <span class="n">base_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">base_name_latex</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>        
        
        
    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_points</span> <span class="o">=</span> <span class="n">_as_2d_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_points</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cover.base_points&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="o">=</span> <span class="n">_as_2d_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cover.landmarks&quot;</span><span class="p">)</span>        
    
    <span class="k">def</span><span class="w"> </span><span class="nf">normalize_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_points</span> <span class="o">=</span> <span class="n">_as_2d_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_points</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cover.base_points&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="o">=</span> <span class="n">_as_2d_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cover.landmarks&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ensure_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize self.metric into a vectorized Metric object with .pairwise.</span>
<span class="sd">        Defaults to EuclideanMetric if missing.</span>

<span class="sd">        Also: if the metric carries base_name/base_name_latex and the cover does not</span>
<span class="sd">        already have explicit base labels, inherit them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">EuclideanMetric</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">as_metric</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">)</span>

        <span class="c1"># ---- inherit base labels from metric if user didn&#39;t set cover labels ----</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;base_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="n">bn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="s2">&quot;base_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bn</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_name</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;base_name_latex&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="n">bL</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="s2">&quot;base_name_latex&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bL</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bL</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_name_latex</span> <span class="o">=</span> <span class="n">bL</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span>
                
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CoverBase&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ensure_built</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CoverBase&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pou</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">nerve_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">nerve_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># Optional 3-simplices</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nerve_tetrahedra</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># Nerve visualization</span>
    <span class="c1"># ----------------------------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">show_nerve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_axes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tri_opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span>
        <span class="n">tri_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">,</span>
        <span class="n">cochains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">object</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_cutoff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">highlight_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Edge</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">highlight_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualize the cover nerve as an interactive Plotly figure.</span>

<span class="sd">        This method requires the cover to have landmark coordinates (one per cover set)</span>
<span class="sd">        and a built membership matrix ``U``. It plots:</span>

<span class="sd">        - vertices at ``self.landmarks`` (one point per cover set),</span>
<span class="sd">        - edges from :meth:`nerve_edges`,</span>
<span class="sd">        - optional filled triangles from :meth:`nerve_triangles`.</span>

<span class="sd">        Two modes are supported:</span>

<span class="sd">        **Static mode (no slider)**</span>
<span class="sd">            If ``edge_weights`` is None, a single figure is produced. Optionally, you may:</span>
<span class="sd">            - show triangles with configurable opacity/color,</span>
<span class="sd">            - highlight specific edges,</span>
<span class="sd">            - overlay cochains.</span>

<span class="sd">        **Slider mode (edge filtering)**</span>
<span class="sd">            If ``edge_weights`` is provided, the visualization includes a slider that filters</span>
<span class="sd">            edges by weight threshold (and displays the induced subcomplex). This delegates to</span>
<span class="sd">            :func:`circle_bundles.viz.nerve_plotly.nerve_with_slider`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title :</span>
<span class="sd">            Optional plot title.</span>
<span class="sd">        show_labels :</span>
<span class="sd">            Whether to show vertex labels (set indices) in the plot.</span>
<span class="sd">        show_axes :</span>
<span class="sd">            Whether to show 3D axes in the Plotly scene (useful for debugging).</span>
<span class="sd">        tri_opacity :</span>
<span class="sd">            Opacity for triangle faces (ignored if no triangles are drawn).</span>
<span class="sd">        tri_color :</span>
<span class="sd">            Color used for triangle faces (Plotly color string).</span>
<span class="sd">        cochains :</span>
<span class="sd">            Optional list of cochain dictionaries to overlay on the nerve.</span>
<span class="sd">            Each cochain is a mapping from a simplex (tuple of vertex indices) to a value</span>
<span class="sd">            used by the plotting code (e.g. for coloring). The exact interpretation depends</span>
<span class="sd">            on the nerve plotting utilities.</span>
<span class="sd">        edge_weights :</span>
<span class="sd">            Optional mapping from edges to weights. If provided, enables slider mode.</span>
<span class="sd">            The keys must be canonical edges as returned by :func:`canon_edge` /</span>
<span class="sd">            :meth:`nerve_edges`.</span>
<span class="sd">        edge_cutoff :</span>
<span class="sd">            Optional edge cutoff for static plots (may be ignored in slider mode,</span>
<span class="sd">            depending on the plotting utility).</span>
<span class="sd">        highlight_edges :</span>
<span class="sd">            Optional set of edges to emphasize in a separate style layer.</span>
<span class="sd">        highlight_color :</span>
<span class="sd">            Color used for highlighted edges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig :</span>
<span class="sd">            The Plotly figure object.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If ``landmarks`` or ``U`` is missing (i.e., the cover cannot be visualized).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_built</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;cover.landmarks is missing; cannot visualize nerve.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;cover.U is missing; build the cover first.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edge_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.viz.nerve_plotly</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_nerve_figure</span>

            <span class="n">fig</span> <span class="o">=</span> <span class="n">make_nerve_figure</span><span class="p">(</span>
                <span class="n">landmarks</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span><span class="p">),</span>
                <span class="n">edges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nerve_edges</span><span class="p">()),</span>
                <span class="n">triangles</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nerve_triangles</span><span class="p">()),</span>
                <span class="n">show_labels</span><span class="o">=</span><span class="n">show_labels</span><span class="p">,</span>
                <span class="n">show_axes</span><span class="o">=</span><span class="n">show_axes</span><span class="p">,</span>
                <span class="n">tri_opacity</span><span class="o">=</span><span class="n">tri_opacity</span><span class="p">,</span>
                <span class="n">tri_color</span><span class="o">=</span><span class="n">tri_color</span><span class="p">,</span>
                <span class="n">edge_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">edge_cutoff</span><span class="o">=</span><span class="n">edge_cutoff</span><span class="p">,</span>
                <span class="n">highlight_edges</span><span class="o">=</span><span class="n">highlight_edges</span><span class="p">,</span>
                <span class="n">highlight_color</span><span class="o">=</span><span class="n">highlight_color</span><span class="p">,</span>
                <span class="n">cochains</span><span class="o">=</span><span class="n">cochains</span><span class="p">,</span>
                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">fig</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">.viz.nerve_plotly</span><span class="w"> </span><span class="kn">import</span> <span class="n">nerve_with_slider</span>

        <span class="k">return</span> <span class="n">nerve_with_slider</span><span class="p">(</span>
            <span class="n">cover</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">edge_weights</span><span class="o">=</span><span class="n">edge_weights</span><span class="p">,</span>
            <span class="n">show_labels</span><span class="o">=</span><span class="n">show_labels</span><span class="p">,</span>
            <span class="n">tri_opacity</span><span class="o">=</span><span class="n">tri_opacity</span><span class="p">,</span>
            <span class="n">tri_color</span><span class="o">=</span><span class="n">tri_color</span><span class="p">,</span>
            <span class="n">show_axes</span><span class="o">=</span><span class="n">show_axes</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># Summary</span>
    <span class="c1"># ----------------------------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">summarize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">compute_cardinalities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">plot_kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;box&quot;</span><span class="p">,</span>        <span class="c1"># &quot;box&quot; (default). (Percentile could be re-added later if desired.)</span>
        <span class="n">latex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>    <span class="c1"># &quot;auto&quot; | True | False</span>
        <span class="n">show_tets_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dpi</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
        <span class="n">figsize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NerveSummary</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the cover and its recorded nerve (dimensions 0..3), with optional plots.</span>

<span class="sd">        This function builds (if needed) the cover membership matrix ``U`` and computes:</span>

<span class="sd">        - number of sets and samples,</span>
<span class="sd">        - recorded simplex counts:</span>
<span class="sd">          ``#0-simplices = n_sets``, and counts of recorded edges/triangles/tetrahedra</span>
<span class="sd">          as returned by :meth:`nerve_edges`, :meth:`nerve_triangles`, :meth:`nerve_tetrahedra`,</span>
<span class="sd">        - overlap-order evidence from ``U``:</span>
<span class="sd">          for each sample, how many cover sets contain it (the “overlap order”).</span>

<span class="sd">        A key consistency check is whether the data show overlaps beyond what the cover</span>
<span class="sd">        explicitly records. For example, if some sample lies in ≥5 sets, then the *true*</span>
<span class="sd">        nerve necessarily contains simplices of dimension ≥4. Since this library’s covers</span>
<span class="sd">        typically record simplices only up to dimension 3, we surface this mismatch as a warning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compute_cardinalities :</span>
<span class="sd">            If True, also compute intersection cardinalities for recorded simplices:</span>
<span class="sd">            ``|U_i|``, ``|U_i ∩ U_j|``, ``|U_i ∩ U_j ∩ U_k|``, and optionally 4-way intersections.</span>
<span class="sd">            These populate the ``*_card`` fields of the returned :class:`NerveSummary`.</span>
<span class="sd">        plot :</span>
<span class="sd">            If True, display a plot summarizing the intersection cardinalities.</span>
<span class="sd">            Requires ``compute_cardinalities=True``.</span>
<span class="sd">        plot_kind :</span>
<span class="sd">            Currently only ``&quot;box&quot;`` is supported: box-and-whisker plots of recorded</span>
<span class="sd">            simplex intersection cardinalities, omitting missing dimensions.</span>
<span class="sd">        latex :</span>
<span class="sd">            Controls printing style when ``verbose=True``:</span>
<span class="sd">            - ``&quot;auto&quot;`` (default): attempt rich Markdown display in notebooks, else plain text</span>
<span class="sd">            - True: force Markdown attempt</span>
<span class="sd">            - False: force plain text printing</span>
<span class="sd">        show_tets_plot :</span>
<span class="sd">            If True and tetrahedra cardinalities exist, include them in the plot panel list.</span>
<span class="sd">        dpi, figsize :</span>
<span class="sd">            Plot formatting controls.</span>
<span class="sd">        save_path :</span>
<span class="sd">            If provided and ``plot=True``, save a PDF of the plot using this prefix/path.</span>
<span class="sd">            The function appends ``&quot;_cover_summary.pdf&quot;``.</span>
<span class="sd">        verbose :</span>
<span class="sd">            If True, print/display the summary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary :</span>
<span class="sd">            A :class:`NerveSummary` object containing counts, optional cardinalities,</span>
<span class="sd">            overlap evidence, and any warnings.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If the cover has no membership matrix ``U`` after building (should not happen</span>
<span class="sd">            for correct cover implementations).</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``plot=True`` but ``compute_cardinalities=False``, or if an unsupported</span>
<span class="sd">            ``plot_kind`` is requested.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Printing / warning policy**</span>
<span class="sd">        - If the maximum sample overlap order is &gt; 4 (i.e. some sample lies in ≥5 sets),</span>
<span class="sd">          the summary prints all recorded simplex counts for dimensions 0..3 and includes</span>
<span class="sd">          overlap-order lines (max order and number of samples in ≥5 sets).</span>
<span class="sd">        - Otherwise, it prints counts only up to the last nonzero recorded dimension and</span>
<span class="sd">          adds a single “no recorded simplices in dimensions ≥ …” line.</span>

<span class="sd">        **Interpretation**</span>
<span class="sd">        - Overlap order is computed directly from ``U`` and reflects *evidence in the data*.</span>
<span class="sd">        - Simplex counts are the *recorded* nerve simplices returned by the cover methods.</span>
<span class="sd">          If those counts disagree with the overlap evidence, warnings highlight the mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_built</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;cover.U is missing; build the cover first.&quot;</span><span class="p">)</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">n_sets</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nerve_edges</span><span class="p">())</span>
        <span class="n">tris</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nerve_triangles</span><span class="p">())</span>
        <span class="n">tets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nerve_tetrahedra</span><span class="p">())</span>

        <span class="n">n0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_sets</span><span class="p">)</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tris</span><span class="p">))</span>
        <span class="n">n3</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tets</span><span class="p">))</span>

        <span class="c1"># overlap order per sample (used only for the ≥5 logic + warning)</span>
        <span class="n">sample_overlap</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">max_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_overlap</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="k">if</span> <span class="n">sample_overlap</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="n">max_order_show</span> <span class="o">=</span> <span class="n">max_order</span> <span class="k">if</span> <span class="n">max_order</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">n_ge_5_show</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_overlap</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">))</span> <span class="k">if</span> <span class="n">max_order</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">warnings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">max_order</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># If U has ≥5 overlaps, the true nerve has dims ≥4; if we&#39;re only recording up to 3,</span>
            <span class="c1"># warn about the mismatch explicitly.</span>
            <span class="k">if</span> <span class="n">max_order</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;U contains overlaps of order </span><span class="si">{</span><span class="n">max_order</span><span class="si">}</span><span class="s2"> (so the true nerve has simplices up to dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">max_order</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">), but this cover only records up to 3-simplices.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Also warn if recorded lower-dim counts are unexpectedly zero given the overlap evidence.</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;U indicates ≥5-way overlaps (hence some triple overlaps must exist), &quot;</span>
                    <span class="s2">&quot;but this cover reports 0 recorded 2-simplices.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">n3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;U indicates ≥5-way overlaps (hence some 4-way overlaps must exist), &quot;</span>
                    <span class="s2">&quot;but this cover reports 0 recorded 3-simplices.&quot;</span>
                <span class="p">)</span>

        <span class="n">vert_card</span> <span class="o">=</span> <span class="n">edge_card</span> <span class="o">=</span> <span class="n">tri_card</span> <span class="o">=</span> <span class="n">tet_card</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">compute_cardinalities</span><span class="p">:</span>
            <span class="n">vert_card</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  
            <span class="n">edge_card</span> <span class="o">=</span> <span class="n">_cards_for_simplices</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span> <span class="k">if</span> <span class="n">n1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">tri_card</span> <span class="o">=</span> <span class="n">_cards_for_simplices</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tris</span><span class="p">])</span> <span class="k">if</span> <span class="n">n2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">tet_card</span> <span class="o">=</span> <span class="n">_cards_for_simplices</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tets</span><span class="p">])</span> <span class="k">if</span> <span class="n">n3</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">summ</span> <span class="o">=</span> <span class="n">NerveSummary</span><span class="p">(</span>
            <span class="n">n_sets</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">n_sets</span><span class="p">),</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">n_samples</span><span class="p">),</span>
            <span class="n">n0</span><span class="o">=</span><span class="n">n0</span><span class="p">,</span>
            <span class="n">n1</span><span class="o">=</span><span class="n">n1</span><span class="p">,</span>
            <span class="n">n2</span><span class="o">=</span><span class="n">n2</span><span class="p">,</span>
            <span class="n">n3</span><span class="o">=</span><span class="n">n3</span><span class="p">,</span>
            <span class="n">vert_card</span> <span class="o">=</span> <span class="n">vert_card</span><span class="p">,</span>
            <span class="n">edge_card</span><span class="o">=</span><span class="n">edge_card</span><span class="p">,</span>
            <span class="n">tri_card</span><span class="o">=</span><span class="n">tri_card</span><span class="p">,</span>
            <span class="n">tet_card</span><span class="o">=</span><span class="n">tet_card</span><span class="p">,</span>
            <span class="n">sample_overlap_counts</span><span class="o">=</span><span class="n">sample_overlap</span><span class="p">,</span>
            <span class="n">max_overlap_order</span><span class="o">=</span><span class="n">max_order_show</span><span class="p">,</span>
            <span class="n">n_samples_with_overlap_ge_5</span><span class="o">=</span><span class="n">n_ge_5_show</span><span class="p">,</span>
            <span class="n">warnings</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">warnings</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">want_latex</span> <span class="o">=</span> <span class="p">(</span><span class="n">latex</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">latex</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">)</span>
            <span class="n">did_display</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">want_latex</span><span class="p">:</span>
                <span class="n">did_display</span> <span class="o">=</span> <span class="n">_try_display_markdown</span><span class="p">(</span><span class="n">summ</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">())</span> <span class="k">if</span> <span class="p">(</span><span class="n">latex</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">did_display</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">summ</span><span class="o">.</span><span class="n">to_text</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">compute_cardinalities</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;plot=True requires compute_cardinalities=True.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot_kind</span> <span class="o">!=</span> <span class="s2">&quot;box&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Currently only plot_kind=&#39;box&#39; is supported.&quot;</span><span class="p">)</span>
            <span class="n">plot_cover_summary_boxplot</span><span class="p">(</span>
                <span class="n">summ</span><span class="p">,</span>
                <span class="n">show_tets</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show_tets_plot</span><span class="p">),</span>
                <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">,</span>
                <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                <span class="n">save_path</span><span class="o">=</span><span class="n">save_path</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">summ</span>


<span class="c1"># ----------------------------</span>
<span class="c1"># Metric ball cover</span>
<span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="MetricBallCover">
<a class="viewcode-back" href="../../api/generated/circle_bundles.MetricBallCover.html#circle_bundles.MetricBallCover">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MetricBallCover</span><span class="p">(</span><span class="n">CoverBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cover by metric balls centered at landmark points.</span>

<span class="sd">    Given base points ``x_s`` and landmark centers ``ℓ_i``, this cover defines:</span>

<span class="sd">    - membership: ``U[i,s] = (d(ℓ_i, x_s) &lt; radius)``</span>
<span class="sd">    - partition of unity: a linear “hat” weight</span>
<span class="sd">      ``w[i,s] = max(0, 1 - d(ℓ_i, x_s) / radius)``, normalized across sets for each sample.</span>

<span class="sd">    This is a simple, widely useful cover construction for point clouds in Euclidean</span>
<span class="sd">    space or in any space equipped with a vectorized metric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base_points :</span>
<span class="sd">        Array of shape ``(n_samples, dB)`` giving base coordinates.</span>
<span class="sd">    landmarks :</span>
<span class="sd">        Array of shape ``(n_sets, dB)`` giving the cover centers.</span>
<span class="sd">    radius :</span>
<span class="sd">        Ball radius (in the units of the chosen metric).</span>
<span class="sd">    metric :</span>
<span class="sd">        Distance model. May be:</span>
<span class="sd">        - a Metric-like object with ``pairwise(X, Y=None)``, or</span>
<span class="sd">        - a scalar callable ``metric(p, q)`` (requires SciPy for vectorization fallback), or</span>
<span class="sd">        - None (defaults to :class:`~circle_bundles.metrics.EuclideanMetric`).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The cover sets are *open* balls (strict inequality).</span>
<span class="sd">    - The recorded nerve is computed directly from ``U`` by checking whether</span>
<span class="sd">      intersections are nonempty (for edges, triangles, and tetrahedra).</span>
<span class="sd">    - If a sample lies in no sets (possible if radius is too small), the current</span>
<span class="sd">      POU normalization leaves that sample with all-zero weights.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    TriangulationStarCover :</span>
<span class="sd">        Cover induced by open stars in a triangulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MetricBallCover.__init__">
<a class="viewcode-back" href="../../api/generated/circle_bundles.MetricBallCover.html#circle_bundles.MetricBallCover.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">landmarks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base_points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">base_points</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">landmarks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_metric</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize_shapes</span><span class="p">()</span></div>


<div class="viewcode-block" id="MetricBallCover.build">
<a class="viewcode-back" href="../../api/generated/circle_bundles.MetricBallCover.html#circle_bundles.MetricBallCover.build">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MetricBallCover&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the cover membership matrix ``U`` and partition of unity ``pou``.</span>

<span class="sd">        Populates</span>
<span class="sd">        ---------</span>
<span class="sd">        U :</span>
<span class="sd">            Boolean array of shape ``(n_sets, n_samples)`` where ``U[i,s]`` indicates</span>
<span class="sd">            whether sample ``s`` lies in the radius-ball around landmark ``i``.</span>
<span class="sd">        pou :</span>
<span class="sd">            Float array of shape ``(n_sets, n_samples)`` giving normalized linear</span>
<span class="sd">            hat weights over the sets containing each sample.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self :</span>
<span class="sd">            The built cover (for chaining).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;MetricBallCover requires landmarks.&quot;</span><span class="p">)</span>

        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_metric</span><span class="p">()</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">pairwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_points</span><span class="p">))</span>  <span class="c1"># (n_sets, n_samples)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>

        <span class="c1"># Linear hat POU, normalized</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">dist</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">denom</span><span class="p">[</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pou</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MetricBallCover.nerve_edges">
<a class="viewcode-back" href="../../api/generated/circle_bundles.MetricBallCover.html#circle_bundles.MetricBallCover.nerve_edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nerve_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recorded 1-simplices of the nerve.</span>

<span class="sd">        An edge (i,j) is included when the intersection ``U_i ∩ U_j`` contains</span>
<span class="sd">        at least one sample.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        edges :</span>
<span class="sd">            List of canonical edges ``(i,j)`` with ``i &lt; j``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_built</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">n_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="p">):</span>
            <span class="n">Uj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Uj</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">canon_edge</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">edges</span></div>


<div class="viewcode-block" id="MetricBallCover.nerve_triangles">
<a class="viewcode-back" href="../../api/generated/circle_bundles.MetricBallCover.html#circle_bundles.MetricBallCover.nerve_triangles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nerve_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recorded 2-simplices of the nerve.</span>

<span class="sd">        A triangle (i,j,k) is included when the triple intersection</span>
<span class="sd">        ``U_i ∩ U_j ∩ U_k`` is nonempty.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        triangles :</span>
<span class="sd">            List of canonical triangles ``(i,j,k)`` with ``i &lt; j &lt; k``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_built</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">n_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tris</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="p">):</span>
            <span class="n">Ui</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                <span class="n">ij</span> <span class="o">=</span> <span class="n">Ui</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ij</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ij</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="n">tris</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">canon_tri</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tris</span></div>


<div class="viewcode-block" id="MetricBallCover.nerve_tetrahedra">
<a class="viewcode-back" href="../../api/generated/circle_bundles.MetricBallCover.html#circle_bundles.MetricBallCover.nerve_tetrahedra">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nerve_tetrahedra</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recorded 3-simplices of the nerve.</span>

<span class="sd">        A tetrahedron (i,j,k,ℓ) is included when the 4-way intersection</span>
<span class="sd">        ``U_i ∩ U_j ∩ U_k ∩ U_ℓ`` is nonempty.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tetrahedra :</span>
<span class="sd">            List of canonical 4-tuples ``(i,j,k,ℓ)`` with ``i &lt; j &lt; k &lt; ℓ``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_built</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">n_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="p">):</span>
            <span class="n">Ui</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                <span class="n">ij</span> <span class="o">=</span> <span class="n">Ui</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ij</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                    <span class="n">ijk</span> <span class="o">=</span> <span class="n">ij</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ijk</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ijk</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">l</span><span class="p">]):</span>
                            <span class="n">tets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">canon_tet</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tets</span></div>
</div>


<span class="c1"># ----------------------------</span>
<span class="c1"># Triangulation star cover</span>
<span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="TriangulationStarCover">
<a class="viewcode-back" href="../../api/generated/circle_bundles.TriangulationStarCover.html#circle_bundles.TriangulationStarCover">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TriangulationStarCover</span><span class="p">(</span><span class="n">CoverBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cover by open stars of vertices in a triangulation.</span>

<span class="sd">    This cover is defined from a simplicial complex ``K`` that triangulates a base</span>
<span class="sd">    space (typically 2D for this implementation), together with “preimages”</span>
<span class="sd">    ``K_preimages`` giving each sample’s location in the geometric realization ``|K|``.</span>

<span class="sd">    Each cover set corresponds to a vertex ``v`` of ``K`` and contains samples whose</span>
<span class="sd">    assigned triangle includes that vertex (i.e. samples lying in triangles incident</span>
<span class="sd">    to ``v``). The partition of unity is defined using barycentric coordinates within</span>
<span class="sd">    the assigned triangle: the three vertices of the triangle receive the barycentric</span>
<span class="sd">    weights, and all other vertices receive weight 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base_points :</span>
<span class="sd">        Array of shape ``(n_samples, dB)``. Kept for consistency with other covers.</span>
<span class="sd">        (This cover uses ``K_preimages`` for assignment/POU.)</span>
<span class="sd">    K_preimages :</span>
<span class="sd">        Array of shape ``(n_samples, D)`` giving each sample’s position in the</span>
<span class="sd">        coordinate system used by ``vertex_coords_dict`` (i.e. coordinates for</span>
<span class="sd">        the geometric realization of ``K``).</span>
<span class="sd">    K :</span>
<span class="sd">        Simplicial complex object with a Gudhi-like interface:</span>
<span class="sd">        ``K.get_simplices()`` yields ``(simplex_tuple, filtration_value)``.</span>
<span class="sd">        This implementation expects at least 1- and 2-simplices.</span>
<span class="sd">    vertex_coords_dict :</span>
<span class="sd">        Mapping ``old_vertex_id -&gt; coords`` where ``coords`` has shape ``(D,)``.</span>
<span class="sd">        Vertex ids need not be contiguous; this cover relabels them to ``0..nV-1``.</span>
<span class="sd">    metric :</span>
<span class="sd">        Optional metric (not used for construction here), but accepted for API</span>
<span class="sd">        uniformity and for downstream plotting/labels.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    landmarks :</span>
<span class="sd">        Set to the relabeled vertex coordinates of shape ``(nV, D)`` (after build).</span>
<span class="sd">        These are used for nerve visualization.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This implementation builds ``U`` and ``pou`` from *triangle membership*.</span>
<span class="sd">      It is effectively a 2-complex cover: :meth:`nerve_tetrahedra` is intentionally</span>
<span class="sd">      not exposed (returns ``[]``), even if ``K`` contains 3-simplices.</span>
<span class="sd">    - Every sample must be assigned to some triangle. If not, :meth:`build` raises</span>
<span class="sd">      an error, typically indicating inconsistent preimages or a too-strict tolerance.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MetricBallCover :</span>
<span class="sd">        A cover built from metric balls around landmark points.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TriangulationStarCover.__init__">
<a class="viewcode-back" href="../../api/generated/circle_bundles.TriangulationStarCover.html#circle_bundles.TriangulationStarCover.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">K_preimages</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">vertex_coords_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base_points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">base_points</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K_preimages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">K_preimages</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">vertex_coords_dict</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vid_old_to_new</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vid_new_to_old</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (nV, D)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>       <span class="c1"># list of (i,j,k) in new ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tetrahedra</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>      <span class="c1"># list of (i,j,k,l) in new ids</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sample_tri</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>     <span class="c1"># (n_samples,) triangle index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_bary</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># (n_samples,3)</span></div>


<div class="viewcode-block" id="TriangulationStarCover.build">
<a class="viewcode-back" href="../../api/generated/circle_bundles.TriangulationStarCover.html#circle_bundles.TriangulationStarCover.build">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TriangulationStarCover&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the star cover membership matrix ``U`` and barycentric POU ``pou``.</span>

<span class="sd">        This method:</span>
<span class="sd">        1) relabels vertices to contiguous ids and sets ``landmarks``,</span>
<span class="sd">        2) extracts triangles from ``K``,</span>
<span class="sd">        3) assigns each sample to a triangle using barycentric coordinates,</span>
<span class="sd">        4) builds ``U`` by marking membership in the three incident vertex stars,</span>
<span class="sd">        5) builds ``pou`` from barycentric weights.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self :</span>
<span class="sd">            The built cover (for chaining).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any sample cannot be assigned to a triangle (e.g. inconsistent</span>
<span class="sd">            coordinates or tolerance too strict).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_relabel_vertices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extract_triangles</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extract_tetrahedra</span><span class="p">()</span>          <span class="c1"># extracted but not exposed via the nerve API</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_samples_to_triangles</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_star_sets_U</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_pou_from_barycentric</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="TriangulationStarCover.nerve_edges">
<a class="viewcode-back" href="../../api/generated/circle_bundles.TriangulationStarCover.html#circle_bundles.TriangulationStarCover.nerve_edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nerve_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recorded 1-simplices of the nerve (edges of the triangulation).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        edges :</span>
<span class="sd">            Sorted list of canonical edges in the relabeled vertex ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_built</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">vid_old_to_new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">edges</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">get_simplices</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vid_old_to_new</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">canon_edge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>


<div class="viewcode-block" id="TriangulationStarCover.nerve_triangles">
<a class="viewcode-back" href="../../api/generated/circle_bundles.TriangulationStarCover.html#circle_bundles.TriangulationStarCover.nerve_triangles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nerve_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tri</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recorded 2-simplices of the nerve (triangles of the triangulation).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        triangles :</span>
<span class="sd">            List of canonical triangles in relabeled vertex ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_built</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">triangles</span><span class="p">)</span></div>


<div class="viewcode-block" id="TriangulationStarCover.nerve_tetrahedra">
<a class="viewcode-back" href="../../api/generated/circle_bundles.TriangulationStarCover.html#circle_bundles.TriangulationStarCover.nerve_tetrahedra">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nerve_tetrahedra</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tet</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recorded 3-simplices of the nerve.</span>

<span class="sd">        This cover currently models a 2-complex (triangle-based stars), so we do not</span>
<span class="sd">        expose tetrahedra even if the underlying complex ``K`` contains them.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tetrahedra :</span>
<span class="sd">            Always returns ``[]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_relabel_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Relabel vertex ids to contiguous integers and populate landmark coordinates.</span>

<span class="sd">        Populates</span>
<span class="sd">        ---------</span>
<span class="sd">        vid_old_to_new, vid_new_to_old :</span>
<span class="sd">            Dictionaries mapping between original ids and contiguous ids.</span>
<span class="sd">        vertex_coords :</span>
<span class="sd">            Array of shape ``(nV, D)`` of vertex coordinates.</span>
<span class="sd">        landmarks :</span>
<span class="sd">            Same as ``vertex_coords`` (for nerve visualization).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_vids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vid_old_to_new</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">old_vids</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vid_new_to_old</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vid_old_to_new</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords_dict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">old_vids</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract 2-simplices from ``K`` and store them in canonical form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">vid_old_to_new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">tris</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Tri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">get_simplices</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vid_old_to_new</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">tris</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">canon_tri</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tris</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_tetrahedra</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract 3-simplices from ``K`` (if present) and store them.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This does not change how ``U`` or ``pou`` are constructed (still triangle-based).</span>
<span class="sd">        The tetrahedra are stored only for possible future use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">vid_old_to_new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">tets</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Tet</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">get_simplices</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vid_old_to_new</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">tets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">canon_tet</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tetrahedra</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tets</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assign_samples_to_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign each sample to a triangle by barycentric containment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tol :</span>
<span class="sd">            Numerical tolerance used when deciding whether barycentric coordinates</span>
<span class="sd">            are inside the triangle.</span>

<span class="sd">        Populates</span>
<span class="sd">        ---------</span>
<span class="sd">        sample_tri :</span>
<span class="sd">            Integer array of shape ``(n_samples,)`` giving the assigned triangle index.</span>
<span class="sd">        sample_bary :</span>
<span class="sd">            Float array of shape ``(n_samples, 3)`` giving barycentric coordinates</span>
<span class="sd">            relative to the assigned triangle.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any sample cannot be assigned to any triangle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K_preimages</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_tri</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_bary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">triangles</span><span class="p">):</span>
            <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]]</span>
            <span class="n">bary</span> <span class="o">=</span> <span class="n">get_bary_coords</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">points_in_triangle_mask</span><span class="p">(</span><span class="n">bary</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="n">newly</span> <span class="o">=</span> <span class="n">inside</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_tri</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">newly</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_tri</span><span class="p">[</span><span class="n">newly</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_idx</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_bary</span><span class="p">[</span><span class="n">newly</span><span class="p">]</span> <span class="o">=</span> <span class="n">bary</span><span class="p">[</span><span class="n">newly</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_tri</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Some samples were not assigned to any triangle (bad preimage / tol too strict).&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_star_sets_U</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build membership matrix ``U`` from the assigned triangle per sample.</span>

<span class="sd">        Each sample belongs to exactly three vertex stars: the vertices of its assigned triangle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tri</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">nV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nV</span><span class="p">,</span> <span class="n">nS</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nS</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_tri</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span>
            <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">U</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">U</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_pou_from_barycentric</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build partition of unity ``pou`` from stored barycentric coordinates.</span>

<span class="sd">        For each sample, the three incident vertices receive weights equal to the</span>
<span class="sd">        barycentric coordinates within the assigned triangle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tri</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_bary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">nV</span><span class="p">,</span> <span class="n">nS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">pou</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nV</span><span class="p">,</span> <span class="n">nS</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nS</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_tri</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_bary</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">pou</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
            <span class="n">pou</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="n">pou</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>

        <span class="n">pou</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">pou</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">denom</span><span class="p">[</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pou</span> <span class="o">=</span> <span class="n">pou</span> <span class="o">/</span> <span class="n">denom</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, Brad Turow.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>