

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>circle_bundles.bundle2 &mdash; circle_bundles 0+unknown documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/myst_sphinx_gallery.css?v=92de7a9e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=27db1736"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            circle_bundles
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#basic-installation">Basic installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#optional-dependencies">Optional dependencies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#minimal-working-example">Minimal working example</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../theory/index.html">Theory</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../theory/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../theory/index.html#algorithms">Algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../theory/index.html#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../theory/index.html#cocycle-fitting">Cocycle Fitting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../theory/index.html#classification">Classification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../theory/index.html#coordinatization">Coordinatization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../theory/index.html#algorithm-1-local-trivializations-and-transition-matrices">Algorithm 1: Local Trivializations and Transition Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../theory/index.html#algorithm-2-characteristic-classes">Algorithm 2: Characteristic Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../theory/index.html#algorithm-3-pullback-bundle-coordinates">Algorithm 3: Pullback Bundle Coordinates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../theory/index.html#references">References</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/core.html">Core pipeline</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/core.html#typical-workflow">Typical workflow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/core.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/results.html">Result objects and dataclasses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/results.html#core-result-containers">Core result containers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/results.html#lower-level-result-containers">Lower-level result containers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/results.html#configuration-objects">Configuration objects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/covers.html">Covers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/covers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/metrics.html">Metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/metrics.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/utilities_analysis.html">Analysis utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.fiberwise_clustering.html">circle_bundles.fiberwise_clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_cluster_persistence.html">circle_bundles.get_cluster_persistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_filtered_cluster_graph.html">circle_bundles.get_filtered_cluster_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_fiberwise_pca_grid.html">circle_bundles.plot_fiberwise_pca_grid</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_fiberwise_summary_bars.html">circle_bundles.plot_fiberwise_summary_bars</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_local_pca.html">circle_bundles.get_local_pca</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_local_pca.html">circle_bundles.plot_local_pca</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_local_rips.html">circle_bundles.get_local_rips</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.plot_local_rips.html">circle_bundles.plot_local_rips</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.get_cocycle_dict.html">circle_bundles.get_cocycle_dict</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.lift_base_points.html">circle_bundles.lift_base_points</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/utilities_viz.html">Visualization utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.viz.html">circle_bundles.viz</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/utilities_synthetic.html">Synthetic datasets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.synthetic.html">circle_bundles.synthetic</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/utilities_optical_flow.html">Optical flow utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/generated/circle_bundles.optical_flow.html">circle_bundles.optical_flow</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/auto_examples/index.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/core/index.html">Core</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/01_product_torus.html">Product Torus With Varying Fiber Radius</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/02_foldy_klein_bottle.html">Folded Klein Bottle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/03_synthetic_natural_image_patches.html">Synthetic Natural Image Patches</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/04_triangle_meshes.html">Star Pyramid Meshes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/05_star_density_unwrapping.html">Star Density Unwrapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/core/06_tri_prism_densities.html">Triangle Prism Densities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/optical_flow/index.html">Optical Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/optical_flow/01_optical_flow_torus.html">Extended Torus Model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/quotients/index.html">Quotients</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/quotients/01_quotients_of_s2_trivial.html">Quotients <span class="math notranslate nohighlight">\((\mathbb{S}^{2}\times\mathbb{S}^{1})/\mathbb{Z}_{2}\)</span> As Circle Bundles Over <span class="math notranslate nohighlight">\(\mathbb{RP}^{2}\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/quotients/02_lens_spaces.html">Lens Spaces <span class="math notranslate nohighlight">\(L(p,1) = \mathbb{S}^{3}/\mathbb{Z}_{p}\)</span> As Circle Bundles Over <span class="math notranslate nohighlight">\(\mathbb{S}^{2}\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/auto_examples/quotients/03_non_orientable_over_rp2.html">Quotients <span class="math notranslate nohighlight">\(\mathbb{S}^{3}/(\mathbb{Z}_{2p}\rtimes\mathbb{Z}_{2})\)</span> As Circle Bundles Over <span class="math notranslate nohighlight">\(\mathbb{RP}^{2}\)</span></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/index.html#core">Core</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/index.html#optical-flow">Optical Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/auto_examples/index.html#quotients">Quotients</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">circle_bundles</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">circle_bundles.bundle2</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for circle_bundles.bundle2</h1><div class="highlight"><pre>
<span></span><span class="c1"># circle_bundles/bundle2.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Set</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.nerve.combinatorics</span><span class="w"> </span><span class="kn">import</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">canon_edge</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.o2_cocycle</span><span class="w"> </span><span class="kn">import</span> <span class="n">O2Cocycle</span><span class="p">,</span> <span class="n">estimate_transitions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.trivializations.local_triv</span><span class="w"> </span><span class="kn">import</span> <span class="n">LocalTrivResult</span><span class="p">,</span> <span class="n">compute_local_triv</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.analysis.quality</span><span class="w"> </span><span class="kn">import</span> <span class="n">BundleQualityReport</span><span class="p">,</span> <span class="n">compute_bundle_quality_from_U</span>

<span class="c1"># Summaries (polished + uniform)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.summaries.nerve_summary</span><span class="w"> </span><span class="kn">import</span> <span class="n">summarize_nerve_from_U</span><span class="p">,</span> <span class="n">NerveSummary</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.summaries.local_triv_summary</span><span class="w"> </span><span class="kn">import</span> <span class="n">summarize_local_trivs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.summaries.class_summary</span><span class="w"> </span><span class="kn">import</span> <span class="n">summarize_classes_and_persistence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.summaries.bundle_map_summary</span><span class="w"> </span><span class="kn">import</span> <span class="n">summarize_bundle_map</span><span class="p">,</span> <span class="n">BundleMapSummary</span>

<span class="c1"># classes + persistence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.analysis.class_persistence</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">compute_bundle_persistence</span><span class="p">,</span>
    <span class="n">_edges_for_subcomplex_from_persistence</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># class reps + restricted-class report</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.characteristic_class</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">compute_class_representatives_from_nerve</span><span class="p">,</span>
    <span class="n">compute_class_data_on_complex</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># global trivialization (Singer only) + orientation gauge helper</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.trivializations.global_trivialization</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">build_global_trivialization_singer</span><span class="p">,</span>
    <span class="n">apply_orientation_gauge_to_f</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.trivializations.bundle_map</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">FramePacking</span><span class="p">,</span>
    <span class="n">get_frame_dataset</span> <span class="k">as</span> <span class="n">_get_frame_dataset</span><span class="p">,</span>
    <span class="n">show_bundle_map_summary</span><span class="p">,</span>
    <span class="n">get_bundle_map_v2</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># ----------------------------</span>
<span class="c1"># Return type for get_local_trivs (public-facing)</span>
<span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="LocalTrivsResult">
<a class="viewcode-back" href="../../api/generated/circle_bundles.LocalTrivsResult.html#circle_bundles.LocalTrivsResult">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LocalTrivsResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Minimal, user-facing output of :meth:`Bundle.get_local_trivs`.</span>

<span class="sd">    Fields</span>
<span class="sd">    ------</span>
<span class="sd">    f:</span>
<span class="sd">        Local angles array of shape (n_sets, n_samples). Only meaningful where U[j,i]=True.</span>
<span class="sd">    cocycle:</span>
<span class="sd">        Estimated O(2) cocycle (transition data).</span>
<span class="sd">    quality:</span>
<span class="sd">        Bundle-quality diagnostics. Must include RMS info (edgewise + aggregates).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">cocycle</span><span class="p">:</span> <span class="n">O2Cocycle</span>
    <span class="n">quality</span><span class="p">:</span> <span class="n">BundleQualityReport</span></div>



<span class="c1"># ----------------------------</span>
<span class="c1"># Return type for get_classes</span>
<span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="ClassesAndPersistence">
<a class="viewcode-back" href="../../api/generated/circle_bundles.ClassesAndPersistence.html#circle_bundles.ClassesAndPersistence">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassesAndPersistence</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return container for :meth:`Bundle.get_classes`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    reps:</span>
<span class="sd">        Class representative object computed from the nerve and cocycle (lightweight).</span>
<span class="sd">        The precise type is implementation-defined.</span>
<span class="sd">    persistence:</span>
<span class="sd">        Persistence output describing edge-driven persistence of class/cocycle structure.</span>
<span class="sd">        The precise type is implementation-defined.</span>
<span class="sd">    restricted:</span>
<span class="sd">        Derived characteristic-class report restricted to a chosen subcomplex.</span>
<span class="sd">        The precise type is implementation-defined.</span>
<span class="sd">    summary_text:</span>
<span class="sd">        A plain-text summary (always available) describing class/persistence results.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reps</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">persistence</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">restricted</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">summary_text</span><span class="p">:</span> <span class="nb">str</span></div>



<span class="c1"># ----------------------------</span>
<span class="c1"># Return type for get_bundle_map</span>
<span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="BundleMapResult">
<a class="viewcode-back" href="../../api/generated/circle_bundles.BundleMapResult.html#circle_bundles.BundleMapResult">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BundleMapResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return container for :meth:`Bundle.get_bundle_map`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    F:</span>
<span class="sd">        Global fiber coordinates returned by the solver in the solver&#39;s ambient</span>
<span class="sd">        frame space. Shape is ``(n_samples, D_used)``.</span>
<span class="sd">    pre_F:</span>
<span class="sd">        Pre-projection coordinates (or pre-reduction coordinates) used internally</span>
<span class="sd">        by the v2 bundle-map pipeline. Shape is solver-defined.</span>
<span class="sd">    Omega_used:</span>
<span class="sd">        Edge-indexed O(2) transitions actually used by the solver. Keys are</span>
<span class="sd">        canonicalized edges of type :class:`circle_bundles.nerve.combinatorics.Edge`.</span>
<span class="sd">    Phi_used:</span>
<span class="sd">        Vertex gauge / orientation choices used by the solver (implementation-defined).</span>
<span class="sd">    report:</span>
<span class="sd">        Solver report object (implementation-defined).</span>
<span class="sd">    meta:</span>
<span class="sd">        Light metadata dictionary (weight, packing, ambient_dim, etc.).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">pre_F</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">Omega_used</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="n">Phi_used</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">report</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">meta</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span></div>



<span class="c1"># ----------------------------</span>
<span class="c1"># Bundle</span>
<span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="Bundle">
<a class="viewcode-back" href="../../api/core.html#circle_bundles.Bundle">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primary bundle analysis driver.</span>

<span class="sd">    This class takes either</span>

<span class="sd">    - a minimal :class:`~circle_bundles.covers.Cover` object (holding ``U``, optional ``pou``,</span>
<span class="sd">      and optional ``landmarks``), **or**</span>
<span class="sd">    - a raw membership matrix ``U``,</span>

<span class="sd">    together with total-space data ``X`` (either a point cloud or a distance matrix). It then:</span>

<span class="sd">    1. Builds the nerve simplices (edges/triangles/tetrahedra) **directly from** ``U``.</span>
<span class="sd">    2. Computes local trivializations and an O(2) cocycle on overlaps.</span>
<span class="sd">    3. Computes characteristic-class representatives and edge-driven persistence.</span>
<span class="sd">    4. Optionally computes global bundle-map coordinates and solver summaries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X :</span>
<span class="sd">        Either a point cloud of shape ``(n_samples, D)`` (if ``distance_matrix=False``),</span>
<span class="sd">        or a distance matrix of shape ``(n_samples, n_samples)`` (if ``distance_matrix=True``).</span>
<span class="sd">    U :</span>
<span class="sd">        Boolean membership matrix of shape ``(n_sets, n_samples)``. Entry ``U[j, i]``</span>
<span class="sd">        indicates whether sample ``i`` belongs to chart/set ``j``.</span>
<span class="sd">        Provide exactly one of ``U`` or ``cover``.</span>
<span class="sd">    cover :</span>
<span class="sd">        Optional :class:`~circle_bundles.covers.Cover` object holding ``U`` and (optionally)</span>
<span class="sd">        ``pou`` and ``landmarks``. If provided, its fields are used as defaults.</span>
<span class="sd">        Provide exactly one of ``U`` or ``cover``.</span>
<span class="sd">    distance_matrix :</span>
<span class="sd">        If True, interpret ``X`` as a distance matrix. If False, interpret ``X`` as a point cloud.</span>
<span class="sd">    pou :</span>
<span class="sd">        Optional partition of unity of shape ``(n_sets, n_samples)``. If ``cover`` is provided,</span>
<span class="sd">        this overrides ``cover.pou`` for this Bundle (and does not mutate the cover).</span>
<span class="sd">    landmarks :</span>
<span class="sd">        Optional landmark coordinates of shape ``(n_sets, dB)`` used by visualization helpers.</span>
<span class="sd">        If ``cover`` is provided, this overrides ``cover.landmarks`` for this Bundle.</span>
<span class="sd">    total_metric :</span>
<span class="sd">        Optional metric object passed through to local-trivialization computations.</span>
<span class="sd">        Only used when ``distance_matrix=False``.</span>
<span class="sd">    max_simp_dim :</span>
<span class="sd">        Maximum simplex dimension to precompute from ``U``. Common values are 1, 2, or 3.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This object caches intermediate results. Any method that changes upstream state</span>
<span class="sd">    invalidates downstream caches (e.g., computing new local trivializations clears</span>
<span class="sd">    class/persistence caches).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_REF_ANGLE</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">U</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cover</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Cover&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">distance_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pou</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">landmarks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">total_metric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_simp_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">show_summary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># --- accept either cover or U ---</span>
        <span class="k">if</span> <span class="n">cover</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provide either cover=... or U=...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cover</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">U</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provide only one of cover=... or U=... (not both).&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cover</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">U_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cover</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">pou_use</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span> <span class="s2">&quot;pou&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cover</span><span class="o">.</span><span class="n">pou</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">lm_use</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span> <span class="s2">&quot;landmarks&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cover</span><span class="o">.</span><span class="n">landmarks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">U_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="n">pou_use</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">lm_use</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># explicit overrides win (do not mutate cover)</span>
        <span class="k">if</span> <span class="n">pou</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pou_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pou</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">landmarks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lm_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">landmarks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">U_use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pou</span> <span class="o">=</span> <span class="n">pou_use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="o">=</span> <span class="n">lm_use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_metric</span> <span class="o">=</span> <span class="n">total_metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_simp_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_simp_dim</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">()</span>

        <span class="c1"># --- ALWAYS compute simplices from U (min_points=1) ---</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_U</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_from_U</span><span class="p">(</span><span class="n">min_points</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tris_U</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tris_from_U</span><span class="p">(</span><span class="n">min_points</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_simp_dim</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tets_U</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tets_from_U</span><span class="p">(</span><span class="n">min_points</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_simp_dim</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span>

        <span class="c1"># caches (local triv + cocycle + quality)</span>
        <span class="c1"># NOTE: we still keep LocalTrivResult privately for summary/debug convenience,</span>
        <span class="c1"># but we no longer return it publicly.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_local_triv</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LocalTrivResult</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">O2Cocycle</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BundleQualityReport</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># caches (summaries)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nerve_summary</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NerveSummary</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># caches (classes/persistence)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_reps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_restricted</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># caches (global trivialization)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_F</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># caches (bundle map)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_cache</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">BundleMapResult</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_last</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BundleMapResult</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># caches (bundle-map summary)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BundleMapSummary</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">show_summary</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># requirement helpers (NO auto-running)</span>
    <span class="c1"># ----------------------------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_require_local_trivs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Local trivializations/cocycle/quality not computed.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Run: bundle.get_local_trivs(...) first.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_require_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_reps</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_restricted</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Classes/persistence not computed.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Run: bundle.get_classes(...) first.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_require_pou</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pou_override</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a validated partition of unity, preferring the override if provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pou_override</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">pou_override</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pou</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;This method requires a partition of unity `pou`.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;Provide `pou=...` when constructing Bundle(...), or pass pou=... to this method.&quot;</span>
                <span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pou</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pou must have shape </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span><span class="si">}</span><span class="s2">; got </span><span class="si">{</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># validation / properties</span>
    <span class="c1"># ----------------------------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;U must be 2D (n_sets, n_samples). Got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">n_sets</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;distance_matrix=True requires X to be square (n_samples,n_samples). Got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_samples</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;X has n=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> but U has n_samples=</span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;distance_matrix=False requires X to be a point cloud (n_samples,D). Got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_samples</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;X has n=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> but U has n_samples=</span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_simp_dim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_simp_dim</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_simp_dim must be between 1 and 5.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pou</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pou</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pou must have shape </span><span class="si">{</span><span class="p">(</span><span class="n">n_sets</span><span class="p">,</span><span class="w"> </span><span class="n">n_samples</span><span class="p">)</span><span class="si">}</span><span class="s2">; got </span><span class="si">{</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># simplices from U</span>
    <span class="c1"># ----------------------------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_edges_from_U</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="n">n_sets</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="p">):</span>
            <span class="n">Uj</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Uj</span> <span class="o">&amp;</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tris_from_U</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="n">n_sets</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="p">):</span>
            <span class="n">Ui</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                <span class="n">ij</span> <span class="o">=</span> <span class="n">Ui</span> <span class="o">&amp;</span> <span class="n">U</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ij</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ij</span> <span class="o">&amp;</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tets_from_U</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">min_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="n">n_sets</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">n_sets</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="p">):</span>
            <span class="n">Ui</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                <span class="n">ij</span> <span class="o">=</span> <span class="n">Ui</span> <span class="o">&amp;</span> <span class="n">U</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ij</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                    <span class="n">ijk</span> <span class="o">=</span> <span class="n">ij</span> <span class="o">&amp;</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ijk</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ijk</span> <span class="o">&amp;</span> <span class="n">U</span><span class="p">[</span><span class="n">l</span><span class="p">]))</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="p">:</span>
                            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="c1"># ----------------------------</span>
    <span class="c1"># summaries</span>
    <span class="c1"># ----------------------------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">summarize_nerve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dpi</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
        <span class="n">figsize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NerveSummary</span><span class="p">:</span>
        <span class="n">summ</span> <span class="o">=</span> <span class="n">summarize_nerve_from_U</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
            <span class="n">max_simplex_dim</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_simp_dim</span><span class="p">),</span>
            <span class="n">min_points_simplex</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">force_compute_from_U</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">compute_cardinalities</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">show_tets_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dpi</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">dpi</span><span class="p">),</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">save_path</span><span class="o">=</span><span class="n">save_path</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">latex</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nerve_summary</span> <span class="o">=</span> <span class="n">summ</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">summ</span><span class="o">.</span><span class="n">show_summary</span><span class="p">(</span>
                <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                <span class="n">plot</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;auto&quot;</span> <span class="k">if</span> <span class="n">plot</span> <span class="k">else</span> <span class="kc">False</span><span class="p">),</span>
                <span class="n">show_tets_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dpi</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">dpi</span><span class="p">),</span>
                <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                <span class="n">save_path</span><span class="o">=</span><span class="n">save_path</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">summ</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">summarize_local_trivs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># still supported because we keep _local_triv privately</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_triv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">summ</span> <span class="o">=</span> <span class="n">summarize_local_trivs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_local_triv</span><span class="p">,</span>
            <span class="n">n_sets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">quality</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_quality</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">summ</span><span class="o">.</span><span class="n">show_summary</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summ</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">summarize_classes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">top_k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">show_weight_hist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">hist_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_reps</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_restricted</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">summ</span> <span class="o">=</span> <span class="n">summarize_classes_and_persistence</span><span class="p">(</span>
            <span class="n">reps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_class_reps</span><span class="p">,</span>
            <span class="n">restricted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_class_restricted</span><span class="p">,</span>
            <span class="n">persistence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">summ</span><span class="o">.</span><span class="n">show_summary</span><span class="p">(</span>
                <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                <span class="n">top_k</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">top_k</span><span class="p">),</span>
                <span class="n">show_weight_hist</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show_weight_hist</span><span class="p">),</span>
                <span class="n">hist_bins</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">hist_bins</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">summ</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">summarize_bundle_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span><span class="o">.</span><span class="n">show_summary</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span>

<div class="viewcode-block" id="Bundle.summary">
<a class="viewcode-back" href="../../api/core.html#circle_bundles.Bundle.summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">modes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;nerve&quot;</span><span class="p">,</span> <span class="s2">&quot;local_triv&quot;</span><span class="p">,</span> <span class="s2">&quot;classes&quot;</span><span class="p">,</span> <span class="s2">&quot;bundle_map&quot;</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_weight_hist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">hist_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">object</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display any summaries that are currently available and return them in a dict.</span>

<span class="sd">        By default (``modes=None``), this displays:</span>
<span class="sd">        - ``&quot;nerve&quot;`` (always available),</span>
<span class="sd">        - ``&quot;local_triv&quot;`` if :meth:`get_local_trivs` has been run,</span>
<span class="sd">        - ``&quot;classes&quot;`` if :meth:`get_classes` has been run,</span>
<span class="sd">        - ``&quot;bundle_map&quot;`` if :meth:`get_bundle_map` has been run.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modes:</span>
<span class="sd">            Iterable selecting which summaries to consider. If None, uses the default policy above.</span>
<span class="sd">        show:</span>
<span class="sd">            If True, display summaries in the active frontend.</span>
<span class="sd">        show_weight_hist:</span>
<span class="sd">            Whether to show the edge-weight histogram in the class summary.</span>
<span class="sd">        hist_bins:</span>
<span class="sd">            Histogram bins for the class-summary weight histogram.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Mapping from summary name to summary object (some entries may be ``None`` if unavailable).</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="n">modes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">modes_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;nerve&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_triv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;local_triv&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_class_reps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_restricted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">modes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;classes&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;bundle_map&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modes_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">modes</span><span class="p">)</span>

        <span class="n">out</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">first_shown</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">modes_list</span><span class="p">:</span>
            <span class="n">will_show</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;nerve&quot;</span><span class="p">:</span>
                    <span class="n">will_show</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;local_triv&quot;</span><span class="p">:</span>
                    <span class="n">will_show</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_triv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;classes&quot;</span><span class="p">:</span>
                    <span class="n">will_show</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_class_reps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_restricted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;bundle_map&quot;</span><span class="p">:</span>
                    <span class="n">will_show</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">will_show</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first_shown</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">will_show</span><span class="p">:</span>
                <span class="n">first_shown</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;nerve&quot;</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="s2">&quot;nerve&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_nerve</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;local_triv&quot;</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="s2">&quot;local_triv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_local_trivs</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;classes&quot;</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="s2">&quot;classes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_classes</span><span class="p">(</span>
                    <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span>
                    <span class="n">top_k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">show_weight_hist</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show_weight_hist</span><span class="p">),</span>
                    <span class="n">hist_bins</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">hist_bins</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;bundle_map&quot;</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="s2">&quot;bundle_map&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_bundle_map</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown summary mode </span><span class="si">{</span><span class="n">m</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


    <span class="c1"># ----------------------------</span>
    <span class="c1"># core: local triv + transitions + quality</span>
    <span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="Bundle.get_local_trivs">
<a class="viewcode-back" href="../../api/core.html#circle_bundles.Bundle.get_local_trivs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_local_trivs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">cc</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="s2">&quot;pca2&quot;</span><span class="p">,</span>
        <span class="n">min_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">min_points_edge</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">pou</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_summary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LocalTrivsResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute local trivializations, estimate an O(2) cocycle, and compute diagnostics.</span>

<span class="sd">        This is the upstream computation needed by most later steps:</span>
<span class="sd">        transitions/cocycle estimation and bundle-quality diagnostics.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cc:</span>
<span class="sd">            Local coordinate constructor / charting method passed to</span>
<span class="sd">            :func:`~circle_bundles.trivializations.local_triv.compute_local_triv`</span>
<span class="sd">            (e.g. ``&quot;pca2&quot;``).</span>
<span class="sd">        min_patch_size:</span>
<span class="sd">            Minimum number of samples required to compute a local trivialization on a chart.</span>
<span class="sd">        min_points_edge:</span>
<span class="sd">            Minimum overlap size ``|U_j  U_k|`` required to include an edge (j,k) in cocycle estimation.</span>
<span class="sd">        pou:</span>
<span class="sd">            Optional partition-of-unity override used for computing quality diagnostics.</span>
<span class="sd">            If omitted, uses ``self.pou`` when available. This does not overwrite ``self.pou``.</span>
<span class="sd">        show_summary:</span>
<span class="sd">            If True, display the local-trivialization summary after computing (auto rendering).</span>
<span class="sd">        verbose:</span>
<span class="sd">            Verbosity forwarded to the local trivialization routine.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        LocalTrivsResult</span>
<span class="sd">            Container holding local trivializations, cocycle, and a quality report.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If shapes are inconsistent (e.g. invalid ``pou`` shape).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Calling this method invalidates downstream caches (classes, global trivialization, bundle map).</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># 1) local triv</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">:</span>
            <span class="n">lt</span> <span class="o">=</span> <span class="n">compute_local_triv</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">U</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
                <span class="n">cc</span><span class="o">=</span><span class="n">cc</span><span class="p">,</span>
                <span class="n">total_metric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">min_patch_size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">min_patch_size</span><span class="p">),</span>
                <span class="n">verbose</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">verbose</span><span class="p">),</span>
                <span class="n">fail_fast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lt</span> <span class="o">=</span> <span class="n">compute_local_triv</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
                <span class="n">U</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
                <span class="n">cc</span><span class="o">=</span><span class="n">cc</span><span class="p">,</span>
                <span class="n">total_metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">total_metric</span><span class="p">,</span>
                <span class="n">min_patch_size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">min_patch_size</span><span class="p">),</span>
                <span class="n">verbose</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">verbose</span><span class="p">),</span>
                <span class="n">fail_fast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lt</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># 2) transitions (edges with overlap &gt;= min_points_edge)</span>
        <span class="n">edges_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_from_U</span><span class="p">(</span><span class="n">min_points</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">min_points_edge</span><span class="p">))</span>
        <span class="n">cocycle</span><span class="p">,</span> <span class="n">report</span> <span class="o">=</span> <span class="n">estimate_transitions</span><span class="p">(</span>
            <span class="n">U</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges_est</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">min_points</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">min_points_edge</span><span class="p">),</span>
            <span class="n">ref_angle</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_REF_ANGLE</span><span class="p">),</span>
            <span class="n">fail_fast_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># 3) quality (allow pou override, but do not require it)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">pou</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pou</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pou must have shape </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span><span class="si">}</span><span class="s2">; got </span><span class="si">{</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pou</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pou</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># NOTE: compute_bundle_quality_from_U still accepts local_triv + transitions_report</span>
        <span class="c1"># internally, but we only *store* f + quality + cocycle going forward.</span>
        <span class="n">qual</span> <span class="o">=</span> <span class="n">compute_bundle_quality_from_U</span><span class="p">(</span>
            <span class="n">U</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
            <span class="n">pou</span><span class="o">=</span><span class="n">P</span><span class="p">,</span>
            <span class="n">local_triv</span><span class="o">=</span><span class="n">lt</span><span class="p">,</span>
            <span class="n">cocycle</span><span class="o">=</span><span class="n">cocycle</span><span class="p">,</span>
            <span class="n">transitions_report</span><span class="o">=</span><span class="n">report</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges_est</span><span class="p">,</span>
            <span class="n">triangles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tris_U</span><span class="p">,</span>
            <span class="n">delta_min_points</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">delta_use_euclidean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">delta_fail_fast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">eps_min_points</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">compute_witness</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># cache (keep lt privately for summaries)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_local_triv</span> <span class="o">=</span> <span class="n">lt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span> <span class="o">=</span> <span class="n">cocycle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="o">=</span> <span class="n">qual</span>

        <span class="c1"># invalidate downstream caches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_reps</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_restricted</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_F</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_meta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_last</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># cache nerve summary (computed from U); do not show during compute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summarize_nerve</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_summary</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">modes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;local_triv&quot;</span><span class="p">],</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">LocalTrivsResult</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">cocycle</span><span class="o">=</span><span class="n">cocycle</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="n">qual</span><span class="p">)</span></div>


    <span class="c1"># ----------------------------</span>
    <span class="c1"># classes + persistence</span>
    <span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="Bundle.get_classes">
<a class="viewcode-back" href="../../api/core.html#circle_bundles.Bundle.get_classes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_classes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">edge_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefer_edge_weight</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;rms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rms&quot;</span><span class="p">,</span>
        <span class="n">show_summary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_weight_hist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">hist_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClassesAndPersistence</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute characteristic-class representatives and persistence with respect to the weights filtration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_weights:</span>
<span class="sd">            Optional explicit edge-weight map for the nerve filtration. Keys are vertex-index</span>
<span class="sd">            pairs ``(j, k)`` (order is ignored). Values should be nonnegative and represent</span>
<span class="sd">            &quot;badness&quot; (smaller = better) so that increasing the threshold adds edges.</span>
<span class="sd">            If omitted, weights are derived from the cached transition report using</span>
<span class="sd">            ``prefer_edge_weight``.</span>
<span class="sd">        prefer_edge_weight:</span>
<span class="sd">            Which transition diagnostic to prefer when deriving edge weights automatically.</span>
<span class="sd">            Typical values are ``&quot;rms&quot;`` (RMS angle fit error) or ``&quot;witness&quot;`` (when available).</span>
<span class="sd">            Ignored if ``edge_weights`` is provided.</span>
<span class="sd">        show_summary:</span>
<span class="sd">            If True, display a class + persistence summary in the active frontend.</span>
<span class="sd">        show_weight_hist:</span>
<span class="sd">            If True, include a histogram of the edge-weight distribution in the displayed summary.</span>
<span class="sd">        hist_bins:</span>
<span class="sd">            Number of bins for the edge-weight histogram.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ClassesAndPersistence</span>
<span class="sd">            Container with fields:</span>
<span class="sd">            - ``reps``: class representatives (lightweight; implementation-defined type),</span>
<span class="sd">            - ``persistence``: persistence output (implementation-defined type),</span>
<span class="sd">            - ``restricted``: derived class data computed on the chosen subcomplex,</span>
<span class="sd">            - ``summary_text``: a plain-text description of the results.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If local trivializations/cocycle have not been computed (see prerequisites).</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the selected restriction mode yields an empty subcomplex or if inputs are inconsistent.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Calling this method invalidates downstream caches that depend on class/persistence state</span>
<span class="sd">        (global trivialization and bundle-map caches).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_require_local_trivs</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># ---- 1) reps only ----</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="n">compute_class_representatives_from_nerve</span><span class="p">(</span>
            <span class="n">cocycle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges_U</span><span class="p">,</span>
            <span class="n">triangles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tris_U</span><span class="p">,</span>
            <span class="n">tets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tets_U</span><span class="p">,</span>
            <span class="n">n_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span>
            <span class="n">try_orient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_reps</span> <span class="o">=</span> <span class="n">reps</span>

        <span class="c1"># ---- 2) persistence ----</span>
        <span class="k">if</span> <span class="n">edge_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prefer</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">prefer_edge_weight</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">prefer</span> <span class="o">!=</span> <span class="s2">&quot;rms&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;prefer_edge_weight must be &#39;rms&#39; (or pass edge_weights explicitly).&quot;</span><span class="p">)</span>

            <span class="n">ew_src</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quality</span><span class="p">,</span> <span class="s2">&quot;rms_angle_err&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ew_src</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;quality.rms_angle_err missing; rerun get_local_trivs (or provide edge_weights).&quot;</span><span class="p">)</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ew_src</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edge_weights</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">compute_bundle_persistence</span><span class="p">(</span>
            <span class="n">cover</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">classes</span><span class="o">=</span><span class="n">reps</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges_U</span><span class="p">,</span>
            <span class="n">triangles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tris_U</span><span class="p">,</span>
            <span class="n">tets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tets_U</span><span class="p">,</span>
            <span class="n">edge_weights</span><span class="o">=</span><span class="n">ew</span><span class="p">,</span>
            <span class="n">prefer_edge_weight</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">prefer_edge_weight</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;edge_weights&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ew</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span> <span class="o">=</span> <span class="n">p</span>

        <span class="c1"># ---- 3) restrict + derived class data ----</span>
        <span class="n">kept_edges</span> <span class="o">=</span> <span class="n">_edges_for_subcomplex_from_persistence</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;cocycle&quot;</span><span class="p">)</span>
        <span class="n">kept_edges_set</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">kept_edges</span><span class="p">}</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_induced_tris</span><span class="p">(</span><span class="n">tris</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tris</span><span class="p">:</span>
                <span class="n">eij</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span>
                <span class="n">eik</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>
                <span class="n">ejk</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">eij</span> <span class="ow">in</span> <span class="n">kept_edges_set</span> <span class="ow">and</span> <span class="n">eik</span> <span class="ow">in</span> <span class="n">kept_edges_set</span> <span class="ow">and</span> <span class="n">ejk</span> <span class="ow">in</span> <span class="n">kept_edges_set</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_induced_tets</span><span class="p">(</span><span class="n">tets</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tets</span><span class="p">:</span>
                <span class="n">edges6</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))),</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">))),</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">))),</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))),</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">))),</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">))),</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span> <span class="ow">in</span> <span class="n">kept_edges_set</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges6</span><span class="p">):</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">tris_sub</span> <span class="o">=</span> <span class="n">_induced_tris</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tris_U</span><span class="p">)</span>
        <span class="n">tets_sub</span> <span class="o">=</span> <span class="n">_induced_tets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tets_U</span><span class="p">)</span>

        <span class="n">restricted</span> <span class="o">=</span> <span class="n">compute_class_data_on_complex</span><span class="p">(</span>
            <span class="n">reps</span><span class="o">=</span><span class="n">reps</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">kept_edges</span><span class="p">,</span>
            <span class="n">triangles</span><span class="o">=</span><span class="n">tris_sub</span><span class="p">,</span>
            <span class="n">tets</span><span class="o">=</span><span class="n">tets_sub</span><span class="p">,</span>
            <span class="n">n_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span>
            <span class="n">compute_euler_num</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_restricted</span> <span class="o">=</span> <span class="n">restricted</span>

        <span class="n">summ</span> <span class="o">=</span> <span class="n">summarize_classes_and_persistence</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="n">reps</span><span class="p">,</span> <span class="n">restricted</span><span class="o">=</span><span class="n">restricted</span><span class="p">,</span> <span class="n">persistence</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="n">summary_text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">summ</span><span class="o">.</span><span class="n">summary_text</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_summary</span><span class="p">:</span>
            <span class="n">summ</span><span class="o">.</span><span class="n">show_summary</span><span class="p">(</span>
                <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                <span class="n">top_k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">show_weight_hist</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show_weight_hist</span><span class="p">),</span>
                <span class="n">hist_bins</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">hist_bins</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="c1"># invalidate downstream caches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_F</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_meta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_last</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ClassesAndPersistence</span><span class="p">(</span>
            <span class="n">reps</span><span class="o">=</span><span class="n">reps</span><span class="p">,</span>
            <span class="n">persistence</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">restricted</span><span class="o">=</span><span class="n">restricted</span><span class="p">,</span>
            <span class="n">summary_text</span><span class="o">=</span><span class="n">summary_text</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># ----------------------------</span>
    <span class="c1"># global trivialization (Singer only)</span>
    <span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="Bundle.get_global_trivialization">
<a class="viewcode-back" href="../../api/core.html#circle_bundles.Bundle.get_global_trivialization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_global_trivialization</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">pou</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a global circle-valued coordinate using the Singer construction.</span>

<span class="sd">        This method produces a *global* fiber coordinate (an :math:`\\mathbb{S}^1`-valued</span>
<span class="sd">        coordinatization) by solving a Singer-type global alignment problem on a certified</span>
<span class="sd">        orientable 1-skeleton, and then blending local angles using a partition of unity.</span>

<span class="sd">        The returned array ``F`` is a global coordinate representation in :math:`\\mathbb{R}^2`</span>
<span class="sd">        (e.g., cosine/sine embedding), suitable for downstream visualization or learning.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight:</span>
<span class="sd">            Optional edge-weight threshold used to further restrict the certified max-trivial</span>
<span class="sd">            subcomplex. If None, the maximal-trivial cutoff is used.</span>
<span class="sd">            If provided, it must be less than or equal to the maximal-trivial threshold;</span>
<span class="sd">            otherwise an error is raised.</span>
<span class="sd">        pou:</span>
<span class="sd">            Optional partition-of-unity override of shape ``(n_sets, n_samples)``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Global fiber coordinate array of shape ``(n_samples, 2)`` (degree-normalized).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If prerequisites have not been computed (see above), or if no partition of unity</span>
<span class="sd">            is available via ``pou`` or ``self.pou``.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the maximal-trivial certified subcomplex is empty, if the chosen threshold yields</span>
<span class="sd">            no usable edges, if the cocycle is non-orientable on the selected subcomplex, or if</span>
<span class="sd">            ``weight`` exceeds the maximal-trivial threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">_require_local_trivs</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Run bundle.get_classes(...) before get_global_trivialization().&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_require_pou</span><span class="p">(</span><span class="n">pou</span><span class="p">)</span>

        <span class="c1"># edge weights from quality (RMS-by-edge)</span>
        <span class="n">ew_src</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quality</span><span class="p">,</span> <span class="s2">&quot;rms_angle_err&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ew_src</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;quality.rms_angle_err missing; cannot build global trivialization weights.&quot;</span><span class="p">)</span>
        <span class="n">ew</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ew_src</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">kept_edges_max</span> <span class="o">=</span> <span class="n">_edges_for_subcomplex_from_persistence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span><span class="p">,</span> <span class="s2">&quot;max_trivial&quot;</span><span class="p">)</span>
        <span class="n">kept_set</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">kept_edges_max</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kept_set</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Max-trivial subcomplex has no edges; cannot build global trivialization.&quot;</span><span class="p">)</span>

        <span class="n">max_allowed_weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ew</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">kept_set</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">max_allowed_weight</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing edge weights on max-trivial edges; cannot select a threshold.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_allowed_weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">max_allowed_weight</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;weight=</span><span class="si">{</span><span class="n">w</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2"> exceeds the maximal-trivial threshold </span><span class="si">{</span><span class="n">max_allowed_weight</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;Choose weight &lt;= max-trivial threshold.&quot;</span>
                <span class="p">)</span>

        <span class="n">edges_stage</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_U</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kept_set</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">ew</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">:</span>
                <span class="n">edges_stage</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">edges_stage</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">edges_stage</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">edges_stage</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No edges remain at this weight within the max-trivial subcomplex.&quot;</span><span class="p">)</span>

        <span class="n">ok</span><span class="p">,</span> <span class="n">coc_oriented</span><span class="p">,</span> <span class="n">phi_pm1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span><span class="o">.</span><span class="n">orient_if_possible</span><span class="p">(</span>
            <span class="n">edges_stage</span><span class="p">,</span>
            <span class="n">n_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span>
            <span class="n">require_all_edges_present</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot build a global S coordinate: the cocycle is non-orientable &quot;</span>
                <span class="s2">&quot;on the selected subcomplex (w does not trivialize there).&quot;</span>
            <span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">apply_orientation_gauge_to_f</span><span class="p">(</span>
            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
            <span class="n">phi_pm1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi_pm1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">ref_angle</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_REF_ANGLE</span><span class="p">),</span>
            <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">theta_use</span> <span class="o">=</span> <span class="n">coc_oriented</span><span class="o">.</span><span class="n">theta</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">build_global_trivialization_singer</span><span class="p">(</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges_stage</span><span class="p">,</span>
            <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span>
            <span class="n">pou</span><span class="o">=</span><span class="n">P</span><span class="p">,</span>
            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
            <span class="n">theta</span><span class="o">=</span><span class="n">theta_use</span><span class="p">,</span>
            <span class="n">n_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>


    <span class="c1"># ----------------------------</span>
    <span class="c1"># bundle-map: frames + coordinates (NO pullback object)</span>
    <span class="c1"># ----------------------------</span>

<div class="viewcode-block" id="Bundle.get_frame_dataset">
<a class="viewcode-back" href="../../api/core.html#circle_bundles.Bundle.get_frame_dataset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_frame_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">pou</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">packing</span><span class="p">:</span> <span class="n">FramePacking</span> <span class="o">=</span> <span class="s2">&quot;coloring2&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the pre-projection frame dataset used by the bundle-map solver.</span>

<span class="sd">        This method constructs the intermediate &quot;frame&quot; representation used by the</span>
<span class="sd">        bundle-map pipeline *before* any projection/reduction step. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pou:</span>
<span class="sd">            Optional partition-of-unity override of shape ``(n_sets, n_samples)``.</span>
<span class="sd">            If omitted, uses ``self.pou``. The override does not overwrite ``self.pou``.</span>
<span class="sd">        weight:</span>
<span class="sd">            Optional edge-weight threshold used to restrict the cocycle-certified subcomplex.</span>
<span class="sd">            If None, the full cocycle-certified subcomplex is used.</span>
<span class="sd">            If provided, it must be &lt;= the cocycle-certification threshold (the largest weight</span>
<span class="sd">            at which the class representatives still certify as cocycles).</span>
<span class="sd">        packing:</span>
<span class="sd">            Frame-packing strategy used when assembling the frame dataset (implementation-defined).</span>
<span class="sd">            Typical values include ``&quot;coloring2&quot;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            A frame dataset object produced by the internal v2 pipeline (implementation-defined type).</span>
<span class="sd">            The returned dataset corresponds to ``stage=&quot;pre_projection&quot;``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If prerequisites have not been computed, or if no partition of unity is available.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the cocycle-certified subcomplex is empty, or if ``weight`` exceeds the cocycle</span>
<span class="sd">            certification threshold, or if thresholding yields no edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_require_local_trivs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_require_classes</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_require_pou</span><span class="p">(</span><span class="n">pou</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span>
        <span class="k">assert</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">ew</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;edge_weights&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ew</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ew_src</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quality</span><span class="p">,</span> <span class="s2">&quot;rms_angle_err&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ew_src</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No edge weights available (p.edge_weights missing and quality.rms_angle_err missing).&quot;</span><span class="p">)</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ew_src</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">cocycle_edges</span> <span class="o">=</span> <span class="n">_edges_for_subcomplex_from_persistence</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;cocycle&quot;</span><span class="p">)</span>
        <span class="n">cocycle_set</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cocycle_edges</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cocycle_set</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cocycle subcomplex has no edges; cannot build frame dataset.&quot;</span><span class="p">)</span>

        <span class="n">w_cocycle</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ew</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">cocycle_set</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ew</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges_used</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cocycle_set</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">w_cocycle</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;weight=</span><span class="si">{</span><span class="n">w</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2"> exceeds the cocycle-certification threshold </span><span class="si">{</span><span class="n">w_cocycle</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;Choose weight &lt;= cocycle threshold.&quot;</span>
                <span class="p">)</span>
            <span class="n">edges_used</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">cocycle_set</span> <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">ew</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">edges_used</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No edges remain at this weight within the cocycle subcomplex.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_get_frame_dataset</span><span class="p">(</span>
            <span class="n">U</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
            <span class="n">pou</span><span class="o">=</span><span class="n">P</span><span class="p">,</span>
            <span class="n">Omega</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span><span class="o">.</span><span class="n">Omega</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges_used</span><span class="p">,</span>
            <span class="n">reducer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">stage</span><span class="o">=</span><span class="s2">&quot;pre_projection&quot;</span><span class="p">,</span>
            <span class="n">max_frames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">rng_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">packing</span><span class="o">=</span><span class="n">packing</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_bundle_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">pou</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reducer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">packing</span><span class="p">:</span> <span class="n">FramePacking</span> <span class="o">=</span> <span class="s2">&quot;coloring2&quot;</span><span class="p">,</span>
        <span class="n">strict_semicircle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_summary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">recompute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BundleMapResult</span><span class="p">:</span>
        <span class="n">SEMICIRCLE_TOL</span> <span class="o">=</span> <span class="mf">1e-8</span>
        <span class="n">ROUNDING</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">COMPUTE_CD</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute (or fetch cached) bundle-map coordinatization.</span>

<span class="sd">        This method returns a global fiber-coordinate embedding produced by the bundle-map</span>
<span class="sd">        solver, along with the solver report and lightweight metadata. The output is intended</span>
<span class="sd">        to serve as a *global coordinatization* of the total space/fiber structure implied by</span>
<span class="sd">        the estimated cocycle, suitable for visualization and downstream learning tasks.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pou:</span>
<span class="sd">            Optional partition-of-unity override of shape ``(n_sets, n_samples)``.</span>
<span class="sd">            If omitted, uses ``self.pou``. The override does not overwrite ``self.pou``.</span>
<span class="sd">        weight:</span>
<span class="sd">            Optional edge-weight threshold used to restrict the cocycle-certified subcomplex.</span>
<span class="sd">            If None, uses the full cocycle-certified subcomplex.</span>
<span class="sd">        reducer:</span>
<span class="sd">            Optional reducer/projection object for the v2 pipeline (implementation-defined).</span>
<span class="sd">            If provided, it participates in caching via a lightweight key derived from common</span>
<span class="sd">            reducer attributes (e.g., method, stage, target dimension).</span>
<span class="sd">        packing:</span>
<span class="sd">            Frame-packing strategy used by the solver (implementation-defined).</span>
<span class="sd">        strict_semicircle:</span>
<span class="sd">            If True, enforce a stricter semicircle constraint in the v2 solver.</span>
<span class="sd">        show_summary:</span>
<span class="sd">            If True, display the bundle-map solver summary in the active frontend.</span>
<span class="sd">        recompute:</span>
<span class="sd">            If True, force recomputation even if a matching result is available in the cache.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BundleMapResult</span>
<span class="sd">            Object with fields:</span>
<span class="sd">            - ``F``: global fiber coordinates of shape ``(n_samples, D_used)``,</span>
<span class="sd">            - ``pre_F``: pre-projection coordinates (solver-defined),</span>
<span class="sd">            - ``Omega_used``: edge-indexed transitions used by the solver,</span>
<span class="sd">            - ``Phi_used``: vertex gauge/orientation choices used by the solver,</span>
<span class="sd">            - ``report``: solver report (implementation-defined),</span>
<span class="sd">            - ``meta``: metadata dict (e.g., weight, packing, ambient_dim, reducer summary).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If prerequisites have not been computed, or if no partition of unity is available.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the cocycle-certified subcomplex is empty, if ``weight`` exceeds the cocycle</span>
<span class="sd">            certification threshold, or if thresholding yields no edges.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Results are cached on the :class:`Bundle` instance. The cache key depends on:</span>
<span class="sd">        the chosen subcomplex (via ``weight``), ``packing``, ``strict_semicircle``, the reducer</span>
<span class="sd">        signature, and whether a partition-of-unity override is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_require_local_trivs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_require_classes</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_require_pou</span><span class="p">(</span><span class="n">pou</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_persistence</span>
        <span class="k">assert</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">ew</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;edge_weights&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ew</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ew_src</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quality</span><span class="p">,</span> <span class="s2">&quot;rms_angle_err&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ew_src</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No edge weights available (p.edge_weights missing and quality.rms_angle_err missing).&quot;</span><span class="p">)</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ew_src</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">cocycle_edges</span> <span class="o">=</span> <span class="n">_edges_for_subcomplex_from_persistence</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;cocycle&quot;</span><span class="p">)</span>
        <span class="n">cocycle_set</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cocycle_edges</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cocycle_set</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cocycle subcomplex has no edges; cannot compute bundle map.&quot;</span><span class="p">)</span>

        <span class="n">w_cocycle</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ew</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">cocycle_set</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ew</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges_used</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cocycle_set</span><span class="p">)</span>
            <span class="n">weight_used</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">w_cocycle</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;weight=</span><span class="si">{</span><span class="n">w</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2"> exceeds the cocycle-certification threshold </span><span class="si">{</span><span class="n">w_cocycle</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;Choose weight &lt;= cocycle threshold.&quot;</span>
                <span class="p">)</span>
            <span class="n">edges_used</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">cocycle_set</span> <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">ew</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">edges_used</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No edges remain at this weight within the cocycle subcomplex.&quot;</span><span class="p">)</span>
            <span class="n">weight_used</span> <span class="o">=</span> <span class="n">w</span>

        <span class="n">edges_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">({</span><span class="n">canon_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_used</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]}))</span>

        <span class="n">red_key</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">reducer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">red_key</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;stage&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;max_frames&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;rng_seed&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;psc_verbosity&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="n">pou_key</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">pou</span><span class="p">)</span> <span class="k">if</span> <span class="n">pou</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;bundle_map_v2&quot;</span><span class="p">,</span>
            <span class="n">edges_key</span><span class="p">,</span>
            <span class="n">weight_used</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">packing</span><span class="p">),</span>
            <span class="nb">bool</span><span class="p">(</span><span class="n">strict_semicircle</span><span class="p">),</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">SEMICIRCLE_TOL</span><span class="p">),</span>
            <span class="n">red_key</span><span class="p">,</span>
            <span class="nb">bool</span><span class="p">(</span><span class="n">COMPUTE_CD</span><span class="p">),</span>
            <span class="n">pou_key</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">recompute</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_cache</span><span class="p">:</span>
            <span class="n">cocycle_edges_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_edges_for_subcomplex_from_persistence</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;cocycle&quot;</span><span class="p">))</span>

            <span class="n">F</span><span class="p">,</span> <span class="n">pre_F</span><span class="p">,</span> <span class="n">Omega_used</span><span class="p">,</span> <span class="n">Phi_used</span><span class="p">,</span> <span class="n">report</span> <span class="o">=</span> <span class="n">get_bundle_map_v2</span><span class="p">(</span>
                <span class="n">U</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
                <span class="n">pou</span><span class="o">=</span><span class="n">P</span><span class="p">,</span>
                <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span>
                <span class="n">Omega</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span><span class="o">.</span><span class="n">Omega</span><span class="p">,</span>
                <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="n">weight_used</span><span class="p">,</span>
                <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">,</span>
                <span class="n">packing</span><span class="o">=</span><span class="n">packing</span><span class="p">,</span>
                <span class="n">strict_semicircle</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">strict_semicircle</span><span class="p">),</span>
                <span class="n">show_summary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">compute_chart_disagreement</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">COMPUTE_CD</span><span class="p">),</span>
                <span class="n">persistence</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                <span class="n">cocycle_subcomplex_edges</span><span class="o">=</span><span class="n">cocycle_edges_list</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">reducer_meta</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">reducer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reducer_meta</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s2">&quot;stage&quot;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;stage&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s2">&quot;max_frames&quot;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;max_frames&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s2">&quot;rng_seed&quot;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;rng_seed&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s2">&quot;psc_verbosity&quot;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="s2">&quot;psc_verbosity&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">}</span>

            <span class="n">ambient_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">BundleMapResult</span><span class="p">(</span>
                <span class="n">F</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">F</span><span class="p">),</span>
                <span class="n">pre_F</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pre_F</span><span class="p">),</span>
                <span class="n">Omega_used</span><span class="o">=</span><span class="n">Omega_used</span><span class="p">,</span>
                <span class="n">Phi_used</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Phi_used</span><span class="p">),</span>
                <span class="n">report</span><span class="o">=</span><span class="n">report</span><span class="p">,</span>
                <span class="n">meta</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">weight_used</span><span class="p">,</span>
                    <span class="s2">&quot;strict_semicircle&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">strict_semicircle</span><span class="p">),</span>
                    <span class="s2">&quot;semicircle_tol&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">SEMICIRCLE_TOL</span><span class="p">),</span>
                    <span class="s2">&quot;reducer&quot;</span><span class="p">:</span> <span class="n">reducer_meta</span><span class="p">,</span>
                    <span class="s2">&quot;compute_chart_disagreement&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">COMPUTE_CD</span><span class="p">),</span>
                    <span class="s2">&quot;packing&quot;</span><span class="p">:</span> <span class="n">packing</span><span class="p">,</span>
                    <span class="s2">&quot;subcomplex&quot;</span><span class="p">:</span> <span class="s2">&quot;cocycle&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ambient_dim&quot;</span><span class="p">:</span> <span class="n">ambient_dim</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="n">bm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_last</span> <span class="o">=</span> <span class="n">bm</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span> <span class="o">=</span> <span class="n">summarize_bundle_map</span><span class="p">(</span><span class="n">bm</span><span class="o">.</span><span class="n">report</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">bm</span><span class="o">.</span><span class="n">meta</span> <span class="ow">or</span> <span class="p">{}))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">show_summary</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bundle_map_summary</span><span class="o">.</span><span class="n">show_summary</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ROUNDING</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">show_bundle_map_summary</span><span class="p">(</span>
                    <span class="n">bm</span><span class="o">.</span><span class="n">report</span><span class="p">,</span>
                    <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                    <span class="n">rounding</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ROUNDING</span><span class="p">),</span>
                    <span class="n">extra_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">bm</span>

    <span class="c1"># --------------</span>
    <span class="c1"># Visualization</span>
    <span class="c1"># --------------</span>

<div class="viewcode-block" id="Bundle.compare_trivs">
<a class="viewcode-back" href="../../api/core.html#circle_bundles.Bundle.compare_trivs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compare_trivs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">ncols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">title_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
        <span class="n">align</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">save_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_pairs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_selected</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">min_points_edge</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare local circular coordinates on overlaps.</span>

<span class="sd">        This method produces a **static matplotlib diagnostic figure** showing pairs of</span>
<span class="sd">        local fiber coordinates on chart overlaps, optionally aligning the second chart</span>
<span class="sd">        to the first by an O(2) fit.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If there are more than ``max_pairs`` overlaps, the visualizer selects a subset</span>
<span class="sd">          according to ``metric`` (typically WORST / MEDIAN / BEST).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ncols:</span>
<span class="sd">            Number of columns in the comparison grid, or ``&quot;auto&quot;`` for an automatic layout.</span>
<span class="sd">        title_size:</span>
<span class="sd">            Font size for subplot titles.</span>
<span class="sd">        align:</span>
<span class="sd">            If True, align the second chart to the first on each overlap using an O(2) fit</span>
<span class="sd">            (useful when comparing angles up to a global reflection/rotation on overlaps).</span>
<span class="sd">        s:</span>
<span class="sd">            Marker size scaling for scatter plots.</span>
<span class="sd">        save_path:</span>
<span class="sd">            Optional path to save the figure (e.g., ``&quot;compare_trivs.png&quot;``).</span>
<span class="sd">        max_pairs:</span>
<span class="sd">            Maximum number of overlap pairs to display.</span>
<span class="sd">        metric:</span>
<span class="sd">            Overlap scoring metric used to rank/select pairs. Common values are:</span>

<span class="sd">            - ``&quot;mean&quot;``: mean circle-fit / angle disagreement on the overlap</span>
<span class="sd">            - ``&quot;rms&quot;``: RMS circle-fit / angle disagreement on the overlap</span>
<span class="sd">        show:</span>
<span class="sd">            If True, display the figure (matplotlib). If False, return the figure without display.</span>
<span class="sd">        return_selected:</span>
<span class="sd">            If True, also return diagnostics about which overlaps were displayed.</span>
<span class="sd">        min_points_edge:</span>
<span class="sd">            Minimum overlap size required to include an edge when ``edges`` is not provided.</span>
<span class="sd">        edges:</span>
<span class="sd">            Optional explicit list of chart-index edges ``[(j, k), ...]`` to consider. If provided,</span>
<span class="sd">            this overrides ``min_points_edge``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.figure.Figure or tuple</span>
<span class="sd">            If ``return_selected=False`` (default), returns the matplotlib figure.</span>

<span class="sd">            If ``return_selected=True``, returns ``(fig, selected_edges, err_by_edge)``, where:</span>

<span class="sd">            - ``selected_edges`` is the list of overlaps actually displayed</span>
<span class="sd">            - ``err_by_edge`` maps each overlap edge to its diagnostic error value</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If local trivializations have not been computed (call :meth:`get_local_trivs` first).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_require_local_trivs</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">.viz.angles</span><span class="w"> </span><span class="kn">import</span> <span class="n">compare_trivs_from_U</span>

        <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_from_U</span><span class="p">(</span><span class="n">min_points</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">min_points_edge</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges_used</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">compare_trivs_from_U</span><span class="p">(</span>
            <span class="n">U</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span>
            <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges_used</span><span class="p">,</span>
            <span class="n">ncols</span><span class="o">=</span><span class="n">ncols</span><span class="p">,</span>
            <span class="n">title_size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">title_size</span><span class="p">),</span>
            <span class="n">align</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">align</span><span class="p">),</span>
            <span class="n">s</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
            <span class="n">save_path</span><span class="o">=</span><span class="n">save_path</span><span class="p">,</span>
            <span class="n">show</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show</span><span class="p">),</span>
            <span class="n">max_pairs</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">max_pairs</span><span class="p">),</span>
            <span class="n">metric</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">metric</span><span class="p">),</span>
            <span class="n">return_selected</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">return_selected</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Bundle.show_nerve">
<a class="viewcode-back" href="../../api/core.html#circle_bundles.Bundle.show_nerve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">show_nerve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">landmarks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_axes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tri_opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span>
        <span class="n">tri_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">,</span>
        <span class="n">cochains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">object</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_cutoff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">highlight_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">highlight_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
        <span class="n">prefer_local_weights</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;rms&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rms&quot;</span><span class="p">,</span>
        <span class="n">use_slider</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mark_cutoff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_title_value</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualize a single-cycle nerve in a canonical circle layout (matplotlib).</span>

<span class="sd">        This visualization is designed for the common case where the 1-skeleton of the</span>
<span class="sd">        nerve is a **single cycle graph**. The vertices are arranged evenly on a circle,</span>
<span class="sd">        and edge annotations (weights, orientation data) are displayed directly on the plot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_max_trivial:</span>
<span class="sd">            If True and persistence results are available, highlight edges belonging to the</span>
<span class="sd">            max-trivial subcomplex (when meaningful). If False, draw all edges uniformly.</span>
<span class="sd">        weights:</span>
<span class="sd">            Weight-label source selector: ``&quot;rms&quot;``, ``&quot;witness&quot;``, or ``&quot;none&quot;``.</span>
<span class="sd">        omega:</span>
<span class="sd">            Optional explicit edge-sign dict mapping ``(i, j)`` to ``1``. If None, an attempt is</span>
<span class="sd">            made to pull a default from cached class representatives.</span>
<span class="sd">        phi:</span>
<span class="sd">            Optional explicit vertex-sign dict mapping vertex index to ``1``.</span>
<span class="sd">        compute_phi:</span>
<span class="sd">            If True and ``phi`` is not provided, attempt to compute a consistent gauge from</span>
<span class="sd">            the cached cocycle. Requires local trivializations/cocycle to have been computed.</span>
<span class="sd">        fail_if_not_cycle:</span>
<span class="sd">            If True (default), raise if the nerve graph is not a single cycle. If False,</span>
<span class="sd">            attempt to visualize &quot;as-is&quot; without canonical cycle reindexing.</span>
<span class="sd">        title:</span>
<span class="sd">            Optional plot title. Defaults to ``&quot;Nerve Visualization&quot;``.</span>
<span class="sd">        save_path:</span>
<span class="sd">            Optional path to save the figure.</span>
<span class="sd">        ax:</span>
<span class="sd">            Optional matplotlib Axes to draw into. If None, a new figure/axes are created.</span>
<span class="sd">        figsize:</span>
<span class="sd">            Figure size (inches) used only when ``ax is None``.</span>
<span class="sd">        dpi:</span>
<span class="sd">            Optional DPI used only when ``ax is None``.</span>
<span class="sd">        r:</span>
<span class="sd">            Radius of the circle layout.</span>
<span class="sd">        node_size, node_facecolor, node_edgecolor, node_label_color:</span>
<span class="sd">            Node styling options.</span>
<span class="sd">        removed_edge_color, removed_edge_lw:</span>
<span class="sd">            Styling for edges not in the highlighted/kept set.</span>
<span class="sd">        kept_edge_color, kept_edge_lw:</span>
<span class="sd">            Styling for highlighted/kept edges.</span>
<span class="sd">        omega_color, phi_color, weights_color:</span>
<span class="sd">            Text colors for omega/phi/weight annotations.</span>
<span class="sd">        fontsize_node, fontsize_omega, fontsize_phi, fontsize_weights:</span>
<span class="sd">            Font sizes for node labels and annotations.</span>
<span class="sd">        omega_offset, weights_offset, phi_offset:</span>
<span class="sd">            Radial offsets used to place text annotations without overlapping edges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.figure.Figure</span>
<span class="sd">            The matplotlib figure.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the Bundle has no cached nerve edges.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``fail_if_not_cycle=True`` and the nerve graph is not a single cycle.</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If ``compute_phi=True`` but no cocycle is available (call :meth:`get_local_trivs` first).</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="kn">from</span><span class="w"> </span><span class="nn">.viz.nerve_plotly</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_nerve_figure</span><span class="p">,</span> <span class="n">nerve_with_slider_from_U</span>

        <span class="k">if</span> <span class="n">landmarks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">cover</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cover&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cover</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span> <span class="s2">&quot;landmarks&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;landmarks&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;No landmarks available for nerve visualization. &quot;</span>
                    <span class="s2">&quot;Pass `landmarks=...` explicitly, or construct the Bundle with a cover &quot;</span>
                    <span class="s2">&quot;that provides landmarks, or store `self.landmarks`.&quot;</span>
                <span class="p">)</span>
            <span class="n">landmarks</span> <span class="o">=</span> <span class="n">L</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">landmarks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_edges_U&quot;</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="n">tris</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_tris_U&quot;</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No nerve edges available on this Bundle (missing/empty _edges_U).&quot;</span><span class="p">)</span>

        <span class="n">ew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_edge_weights</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">prefer_local_weights</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">ew</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">use_slider</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">make_nerve_figure</span><span class="p">(</span>
                <span class="n">landmarks</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
                <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
                <span class="n">triangles</span><span class="o">=</span><span class="n">tris</span><span class="p">,</span>
                <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="n">title</span> <span class="ow">or</span> <span class="s2">&quot;Nerve Visualization&quot;</span><span class="p">),</span>
                <span class="n">show_labels</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show_labels</span><span class="p">),</span>
                <span class="n">show_axes</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show_axes</span><span class="p">),</span>
                <span class="n">tri_opacity</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">tri_opacity</span><span class="p">),</span>
                <span class="n">tri_color</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">tri_color</span><span class="p">),</span>
                <span class="n">cochains</span><span class="o">=</span><span class="n">cochains</span><span class="p">,</span>
                <span class="n">edge_weights</span><span class="o">=</span><span class="n">ew</span><span class="p">,</span>
                <span class="n">edge_cutoff</span><span class="o">=</span><span class="n">edge_cutoff</span><span class="p">,</span>
                <span class="n">highlight_edges</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">highlight_edges</span><span class="p">)</span> <span class="k">if</span> <span class="n">highlight_edges</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">highlight_color</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">highlight_color</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">fig</span>

        <span class="k">if</span> <span class="n">mark_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">jump_cutoff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mark_cutoff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jump_cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_max_trivial_cutoff</span><span class="p">(</span><span class="n">ew</span><span class="p">)</span>

        <span class="n">show_jump</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">jump_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nerve_with_slider_from_U</span><span class="p">(</span>
            <span class="n">U</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="n">landmarks</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
            <span class="n">triangles</span><span class="o">=</span><span class="n">tris</span><span class="p">,</span>
            <span class="n">edge_weights</span><span class="o">=</span><span class="n">ew</span><span class="p">,</span>
            <span class="n">show_labels</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show_labels</span><span class="p">),</span>
            <span class="n">tri_opacity</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">tri_opacity</span><span class="p">),</span>
            <span class="n">tri_color</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">tri_color</span><span class="p">),</span>
            <span class="n">show_axes</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show_axes</span><span class="p">),</span>
            <span class="n">highlight_edges</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">highlight_edges</span><span class="p">)</span> <span class="k">if</span> <span class="n">highlight_edges</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">highlight_color</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">highlight_color</span><span class="p">),</span>
            <span class="n">mark_cutoff</span><span class="o">=</span><span class="n">jump_cutoff</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="p">(</span><span class="n">title</span> <span class="ow">or</span> <span class="s2">&quot;Nerve Visualization&quot;</span><span class="p">),</span>
            <span class="n">show_title_value</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">show_title_value</span><span class="p">),</span>
            <span class="n">show_jump</span><span class="o">=</span><span class="n">show_jump</span><span class="p">,</span>
            <span class="n">jump_label</span><span class="o">=</span><span class="s2">&quot;Jump to max-trivial&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Bundle.show_circle_nerve">
<a class="viewcode-back" href="../../api/core.html#circle_bundles.Bundle.show_circle_nerve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">show_circle_nerve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">use_max_trivial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rms&quot;</span><span class="p">,</span>
        <span class="n">omega</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compute_phi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fail_if_not_cycle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">),</span>
        <span class="n">dpi</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">r</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">node_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span>
        <span class="n">node_facecolor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lightblue&quot;</span><span class="p">,</span>
        <span class="n">node_edgecolor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="n">node_label_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="n">removed_edge_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lightgray&quot;</span><span class="p">,</span>
        <span class="n">removed_edge_lw</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span>
        <span class="n">kept_edge_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="n">kept_edge_lw</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">,</span>
        <span class="n">omega_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
        <span class="n">phi_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
        <span class="n">weights_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="n">fontsize_node</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
        <span class="n">fontsize_omega</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
        <span class="n">fontsize_phi</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
        <span class="n">fontsize_weights</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="n">omega_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.09</span><span class="p">,</span>
        <span class="n">weights_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.09</span><span class="p">,</span>
        <span class="n">phi_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.14</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualize a single-cycle nerve in a canonical circle layout (matplotlib).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.viz.nerve_circle</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
            <span class="n">show_circle_nerve</span> <span class="k">as</span> <span class="n">_show_circle_nerve</span><span class="p">,</span>
            <span class="n">is_single_cycle_graph</span><span class="p">,</span>
            <span class="n">cycle_order_from_edges</span><span class="p">,</span>
            <span class="n">reindex_edges</span><span class="p">,</span>
            <span class="n">reindex_vertex_dict</span><span class="p">,</span>
            <span class="n">reindex_edge_dict</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_edges_U&quot;</span><span class="p">,</span> <span class="p">[]))]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No nerve edges available on this Bundle (missing _edges_U).&quot;</span><span class="p">)</span>

        <span class="n">ok</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">is_single_cycle_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ok</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fail_if_not_cycle</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nerve is not a single cycle graph: </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># ---- kept edges (max-trivial) from persistence ----</span>
        <span class="n">kept_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">use_max_trivial</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_class_persistence&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">kept</span> <span class="o">=</span> <span class="n">_edges_for_subcomplex_from_persistence</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;max_trivial&quot;</span><span class="p">)</span>
                    <span class="n">kept_edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">kept</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">kept_edges</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># fail soft</span>

        <span class="c1"># ---- weights source (no user dict allowed) ----</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;rms&quot;</span><span class="p">,</span> <span class="s2">&quot;witness&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weights must be one of {&#39;rms&#39;,&#39;witness&#39;,&#39;none&#39;}.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># central policy: persistence edge_weights &gt; quality-derived &gt; None</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_edge_weights</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

        <span class="c1"># ---- omega: explicit override OR auto from reps ----</span>
        <span class="n">omega_use</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">omega</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">omega_use</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">omega</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_class_reps&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">cand</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="s2">&quot;omega_O1_used&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">reps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">cand</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega_use</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cand</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># ---- phi ----</span>
        <span class="n">phi_use</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">phi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">phi_use</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">phi</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="n">compute_phi</span><span class="p">:</span>
            <span class="n">coc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_cocycle&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot compute phi: cocycle not computed. Run bundle.get_local_trivs(...) first, &quot;</span>
                    <span class="s2">&quot;or pass phi=... explicitly.&quot;</span>
                <span class="p">)</span>
            <span class="n">edge_set_for_phi</span> <span class="o">=</span> <span class="n">kept_edges</span> <span class="k">if</span> <span class="p">(</span><span class="n">kept_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kept_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="n">edges</span>
            <span class="n">ok_or</span><span class="p">,</span> <span class="n">_coc_oriented</span><span class="p">,</span> <span class="n">phi_pm1</span> <span class="o">=</span> <span class="n">coc</span><span class="o">.</span><span class="n">orient_if_possible</span><span class="p">(</span>
                <span class="n">edge_set_for_phi</span><span class="p">,</span>
                <span class="n">n_vertices</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                <span class="n">require_all_edges_present</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ok_or</span><span class="p">:</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi_pm1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">phi_use</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phi_use</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># ---- reorder around the cycle for clean layout ----</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">cycle_order_from_edges</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">old_to_new</span> <span class="o">=</span> <span class="p">{</span><span class="n">old</span><span class="p">:</span> <span class="n">new</span> <span class="k">for</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">)}</span>

            <span class="n">edges_r</span> <span class="o">=</span> <span class="n">reindex_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">old_to_new</span><span class="p">)</span>
            <span class="n">kept_r</span> <span class="o">=</span> <span class="n">reindex_edges</span><span class="p">(</span><span class="n">kept_edges</span><span class="p">,</span> <span class="n">old_to_new</span><span class="p">)</span> <span class="k">if</span> <span class="n">kept_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">omega_r</span> <span class="o">=</span> <span class="n">reindex_edge_dict</span><span class="p">(</span><span class="n">omega_use</span><span class="p">,</span> <span class="n">old_to_new</span><span class="p">)</span> <span class="k">if</span> <span class="n">omega_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">w_r</span> <span class="o">=</span> <span class="n">reindex_edge_dict</span><span class="p">(</span><span class="n">ew</span><span class="p">,</span> <span class="n">old_to_new</span><span class="p">)</span> <span class="k">if</span> <span class="n">ew</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">phi_r</span> <span class="o">=</span> <span class="n">reindex_vertex_dict</span><span class="p">(</span><span class="n">phi_use</span><span class="p">,</span> <span class="n">old_to_new</span><span class="p">)</span> <span class="k">if</span> <span class="n">phi_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges_r</span><span class="p">,</span> <span class="n">kept_r</span><span class="p">,</span> <span class="n">omega_r</span><span class="p">,</span> <span class="n">w_r</span><span class="p">,</span> <span class="n">phi_r</span> <span class="o">=</span> <span class="n">edges</span><span class="p">,</span> <span class="n">kept_edges</span><span class="p">,</span> <span class="n">omega_use</span><span class="p">,</span> <span class="n">ew</span><span class="p">,</span> <span class="n">phi_use</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Nerve Visualization&quot;</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">_ax</span> <span class="o">=</span> <span class="n">_show_circle_nerve</span><span class="p">(</span>
            <span class="n">n_vertices</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges_r</span><span class="p">,</span>
            <span class="n">kept_edges</span><span class="o">=</span><span class="n">kept_r</span><span class="p">,</span>
            <span class="n">omega</span><span class="o">=</span><span class="n">omega_r</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">w_r</span><span class="p">,</span>
            <span class="n">phi</span><span class="o">=</span><span class="n">phi_r</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">,</span>
            <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span>
            <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span>
            <span class="n">node_facecolor</span><span class="o">=</span><span class="n">node_facecolor</span><span class="p">,</span>
            <span class="n">node_edgecolor</span><span class="o">=</span><span class="n">node_edgecolor</span><span class="p">,</span>
            <span class="n">node_label_color</span><span class="o">=</span><span class="n">node_label_color</span><span class="p">,</span>
            <span class="n">removed_edge_color</span><span class="o">=</span><span class="n">removed_edge_color</span><span class="p">,</span>
            <span class="n">removed_edge_lw</span><span class="o">=</span><span class="n">removed_edge_lw</span><span class="p">,</span>
            <span class="n">kept_edge_color</span><span class="o">=</span><span class="n">kept_edge_color</span><span class="p">,</span>
            <span class="n">kept_edge_lw</span><span class="o">=</span><span class="n">kept_edge_lw</span><span class="p">,</span>
            <span class="n">omega_color</span><span class="o">=</span><span class="n">omega_color</span><span class="p">,</span>
            <span class="n">phi_color</span><span class="o">=</span><span class="n">phi_color</span><span class="p">,</span>
            <span class="n">weights_color</span><span class="o">=</span><span class="n">weights_color</span><span class="p">,</span>
            <span class="n">fontsize_node</span><span class="o">=</span><span class="n">fontsize_node</span><span class="p">,</span>
            <span class="n">fontsize_omega</span><span class="o">=</span><span class="n">fontsize_omega</span><span class="p">,</span>
            <span class="n">fontsize_phi</span><span class="o">=</span><span class="n">fontsize_phi</span><span class="p">,</span>
            <span class="n">fontsize_weights</span><span class="o">=</span><span class="n">fontsize_weights</span><span class="p">,</span>
            <span class="n">omega_offset</span><span class="o">=</span><span class="n">omega_offset</span><span class="p">,</span>
            <span class="n">weights_offset</span><span class="o">=</span><span class="n">weights_offset</span><span class="p">,</span>
            <span class="n">phi_offset</span><span class="o">=</span><span class="n">phi_offset</span><span class="p">,</span>
            <span class="n">save_path</span><span class="o">=</span><span class="n">save_path</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>



    <span class="c1"># ----------------------------</span>
    <span class="c1"># Accessors (NO auto-running)</span>
    <span class="c1"># ----------------------------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_quality</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BundleQualityReport</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Quality not computed. Run: bundle.get_local_trivs(...) first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quality</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_cocycle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">O2Cocycle</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cocycle not computed. Run: bundle.get_local_trivs(...) first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cocycle</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_f</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Local angles not computed. Run: bundle.get_local_trivs(...) first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>

    <span class="c1"># (Back-compat / internal) keep available but not required by the public API.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_local_triv_result</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LocalTrivResult</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_triv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Local trivializations not computed. Run: bundle.get_local_trivs(...) first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_triv</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_try_max_trivial_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_weights</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_class_persistence&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">kept</span> <span class="o">=</span> <span class="n">_edges_for_subcomplex_from_persistence</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;max_trivial&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">kept</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">ew</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edge_weights</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">ew</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">kept</span><span class="p">]</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">ws</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">w</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ws</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ws</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_latest_edge_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">prefer</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rms&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="c1"># 0) explicit override always wins</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># 1) classes/persistence weights (if available)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_class_persistence&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;edge_weights&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ew</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ew</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># 2) quality-derived weights (if available)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_quality&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">prefer</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">prefer</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">prefer</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;rms&quot;</span><span class="p">,</span> <span class="s2">&quot;witness&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;prefer must be &#39;rms&#39;, &#39;witness&#39;, or &#39;none&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prefer</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># witness-by-edge (if you add it later) + graceful fallback to RMS</span>
        <span class="k">if</span> <span class="n">prefer</span> <span class="o">==</span> <span class="s2">&quot;witness&quot;</span><span class="p">:</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s2">&quot;witness_err_by_edge&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ew</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ew</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="c1"># fallback: use RMS if witness weights aren&#39;t available</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s2">&quot;rms_angle_err&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ew</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ew</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># prefer == &quot;rms&quot;</span>
        <span class="n">ew</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s2">&quot;rms_angle_err&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ew</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)))):</span> <span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ew</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, Brad Turow.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>